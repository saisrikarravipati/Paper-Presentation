



package policy.enforcement.scope

###############################################################################
# Constants & Durations
###############################################################################

# The date on which a repo is considered to be in scope for ETB
IN_SCOPE_CUTOFF_DATE := "2024-05-15T00:00:00Z"

# If the repo creation date is strictly after this date, it's considered "net new"
NET_NEW_CUTOFF_DATE := "2024-04-01T00:00:00Z"

# 60 days expressed as a Go-style duration ("1440h" = 60 days * 24 hours)
ENFORCEMENT_DURATION_STR := "1440h"

###############################################################################
# Repo Creation Timestamp in ns
# 
# Some input might be in custom format "2006-01-02T15:04:05",
# otherwise fallback to RFC3339 parse.
###############################################################################
repo_creation_timestamp := parsed_custom if {
    parsed_custom := time.parse_ns("2006-01-02T15:04:05", input.repoCreationDate)
} else := parsed_rfc if {
    parsed_rfc := time.parse_rfc3339_ns(input.repoCreationDate)
}

###############################################################################
# Current Time
# 
# By default, we use time.now_ns(). Tests can override it with "with".
###############################################################################
default current_time_ns = 0
current_time_ns = time.now_ns()

###############################################################################
# Net-New Cutoff in ns
###############################################################################
net_new_cutoff_ns := time.parse_rfc3339_ns(NET_NEW_CUTOFF_DATE)

###############################################################################
# In-Scope Cutoff in ns
###############################################################################
in_scope_cutoff_ns := time.parse_rfc3339_ns(IN_SCOPE_CUTOFF_DATE)

###############################################################################
# 1) Flag: is_repo_net_new
#
# True if the repo creation timestamp is strictly greater than
# the net-new cutoff (2024-04-01T00:00:00Z).
###############################################################################
is_repo_net_new = value if {
    value = repo_creation_timestamp > net_new_cutoff_ns
}

###############################################################################
# 2) Value: full_enforcement_Date
#
# We want an RFC3339 string representing the repo creation date + 60 days.
# "time.add_duration" is in OPA 0.59.0. It adds 1440h (60 days) to an RFC3339.
#
# If your repoCreationDate is parseable only by the custom format, this will
# not succeed. Adjust if needed. For typical RFC3339 inputs, this works fine.
###############################################################################
full_enforcement_Date = enforced_str if {
    # The user wants an RFC3339 result. We can only add durations to an RFC3339 string.
    # If the input was parseable by custom format, we won't have a direct string
    # in RFC3339 format. So let's attempt the fallback approach:
    some_repo_date := fallback_rfc3339_str
    enforced_str := time.add_duration(some_repo_date, ENFORCEMENT_DURATION_STR)
}

# "fallback_rfc3339_str" tries to see if `input.repoCreationDate` is already
# in standard RFC3339 form. If not, you could do a manual conversion (not trivial)
# or simply rely on the user to pass valid RFC3339. For many real scenarios,
# the input is typically in RFC3339, so this works.
fallback_rfc3339_str := input.repoCreationDate if {
    # Just a naive check to see if parse_rfc3339_ns doesn't fail.
    _ := time.parse_rfc3339_ns(input.repoCreationDate)
}

# If your environment only uses RFC3339 creation dates, you can
# skip the custom format parse entirely.

###############################################################################
# 3) Flag: is_repo_fully_enforced
#
# True if:
#   - The repository is net new (creation > 2024-04-01)
#   - The current time is >= creation + 60 days
###############################################################################
is_repo_fully_enforced = result if {
    # Condition 1: net new
    repo_creation_timestamp > net_new_cutoff_ns
    
    # Condition 2: current_time_ns >= (repo_creation_timestamp + 60 days)
    # We don't have time.add_ns, so do integer math:
    enforced_ts_ns := repo_creation_timestamp + 60 * 24 * 3600 * 1000000000
    current_time_ns >= enforced_ts_ns

    result = true
} else = result if {
    result = false
}

###############################################################################
# Existing "ETBinScope" and "in_scope_pipeline" logic, unchanged
###############################################################################
ETBinScope if {
    lower(input.repoUrl) in data.ETB_list
} else {
    false
}

in_scope_pipeline if {
    lower(input.pipelineAppType) in data.valid_types.valid_pipeline_app_type
    input.pipelineFlavor in data.scope_flavors
    in_scope_date = true
}

in_scope_date if {
    repo_creation_timestamp >= in_scope_cutoff_ns
}

out_of_scope_date if {
    input.repoCreationDate != ""
    repo_creation_timestamp < in_scope_cutoff_ns
}

in_scope_date if {
    input.repoCreationDate = ""
}

###############################################################################
# Combine partial results
###############################################################################
scope_results contains decision if {
    in_scope_pipeline = true
    decision := {
        "message": "pass repo app type, date, and flavor in scope",
        "policy_name": "Enforcement Scope policy",
        "decision": "true",
    }
}

scope_results contains decision if {
    ETBinScope
    decision := {
        "message": "pass repo in ETB list",
        "policy_name": "Enforcement Scope policy",
        "decision": "true",
    }
}

scope_results contains decision if {
    not ETBinScope
    not lower(input.pipelineAppType) in data.valid_types.valid_pipeline_app_type
    decision := {
        "message": "App type is not application",
        "policy_name": "Enforcement Scope policy",
        "decision": "false",
    }
}

scope_results contains decision if {
    not ETBinScope
    not input.pipelineFlavor in data.scope_flavors
    decision := {
        "message": "Flavor is not in scope",
        "policy_name": "Enforcement Scope policy",
        "decision": "false",
    }
}

scope_results contains decision if {
    not ETBinScope
    out_of_scope_date = true
    decision := {
        "message": "repo is not in scope",
        "policy_name": "Enforcement Scope policy",
        "decision": "false",
    }
}

###############################################################################
# Final "results" Document
# 
# We add our new fields "is_repo_net_new", "is_repo_fully_enforced",
# and "full_enforcement_Date" to the final response.
###############################################################################
results := response if {
    # Gather sub-decisions
    all_decisions := [decision |
        some res in scope_results
        decision := res.decision
    ]
    all_messages := [message |
        some res in scope_results
        message := res.message
    ]
    decision := make_decision(all_decisions)

    response := {
        "policy_name": "Enforcement Scope policy",
        "decision": decision,
        "messages": all_messages,

        # Original field
        "isRepoInEtbScope": ETBinScope,

        # Newly requested fields
        "is_repo_net_new": is_repo_net_new,
        "is_repo_fully_enforced": is_repo_fully_enforced,
        "full_enforcement_Date": full_enforcement_Date,
    }
}

###############################################################################
# Decide "true" if any sub-decision is "true", "false" if any are "false",
# else "" if none exist.
###############################################################################
make_decision(decisions) := result if {
    "false" in decisions
    result := "false"
} else := result if {
    "true" in decisions
    result := "true"
} else := ""




------------------------




package policy.enforcement.scope_test

import data.policy.enforcement.scope

###############################################################################
# Test 1: Net new and exactly 60 days have passed -> fully_enforced == true
###############################################################################
test_net_new_and_fully_enforced {
    creation := "2024-04-02T00:00:00Z"

    # We can produce the expected "full_enforcement_Date" using time.add_duration.
    expected_enforcement_str := time.add_duration(creation, "1440h")  # 1440h = 60 days

    # "current_time_ns" should be the same as 'creation + 60 days'.
    # We'll parse 'expected_enforcement_str' back to ns and override current_time_ns.
    expected_enforcement_ns := time.parse_rfc3339_ns(expected_enforcement_str)

    input_data := {
        "repoCreationDate": creation,
        "repoUrl": "dummy_repo",
        "pipelineAppType": "application",
        "pipelineFlavor": "flavorA",
    }

    net_new := scope.is_repo_net_new
        with input as input_data

    # Overriding the default current_time_ns
    fully_enforced := scope.is_repo_fully_enforced
        with input as input_data
        with scope.current_time_ns as expected_enforcement_ns

    full_due := scope.full_enforcement_Date
        with input as input_data

    net_new == true
    fully_enforced == true
    full_due == expected_enforcement_str
}

###############################################################################
# Test 2: Net new but fewer than 60 days -> fully_enforced == false
###############################################################################
test_net_new_but_not_fully_enforced {
    creation := "2024-04-02T00:00:00Z"

    # Full enforcement date as an RFC3339 string
    expected_enforcement_str := time.add_duration(creation, "1440h")
    expected_enforcement_ns := time.parse_rfc3339_ns(expected_enforcement_str)

    # We'll simulate that only 30 days have passed:
    partial_duration_str := "720h"  # 30 days
    partial_ts_ns := time.parse_rfc3339_ns(time.add_duration(creation, partial_duration_str))

    input_data := {
        "repoCreationDate": creation,
        "repoUrl": "dummy_repo",
        "pipelineAppType": "application",
        "pipelineFlavor": "flavorA",
    }

    net_new := scope.is_repo_net_new
        with input as input_data

    fully_enforced := scope.is_repo_fully_enforced
        with input as input_data
        with scope.current_time_ns as partial_ts_ns

    full_due := scope.full_enforcement_Date
        with input as input_data

    net_new == true
    fully_enforced == false
    full_due == expected_enforcement_str
}

###############################################################################
# Test 3: Not net new (creation date <= 2024-04-01) -> net_new == false
###############################################################################
test_not_net_new {
    # Before cutoff: "2024-04-01T00:00:00Z" is the boundary; let's pick 2024-03-31
    creation := "2024-03-31T00:00:00Z"

    expected_enforcement_str := time.add_duration(creation, "1440h")

    # Even if we simulate time well past 60 days, it won't matter because it's NOT net new.
    # We go 70 days out, for instance:
    big_duration_str := "1680h" # 70 days
    big_time_ns := time.parse_rfc3339_ns(time.add_duration(creation, big_duration_str))

    input_data := {
        "repoCreationDate": creation,
        "repoUrl": "dummy_repo",
        "pipelineAppType": "application",
        "pipelineFlavor": "flavorA",
    }

    net_new := scope.is_repo_net_new
        with input as input_data

    fully_enforced := scope.is_repo_fully_enforced
        with input as input_data
        with scope.current_time_ns as big_time_ns

    full_due := scope.full_enforcement_Date
        with input as input_data

    net_new == false
    fully_enforced == false
    full_due == expected_enforcement_str
}
