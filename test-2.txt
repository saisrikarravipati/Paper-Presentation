"""
tests/test_db.py
────────────────
Exhaustive tests for lib.collectors.sevenps.storage.postgres
that leave all real logging intact.  No live database is used.
"""
from __future__ import annotations

import importlib
import os
import unittest
from contextlib import contextmanager
from types import ModuleType
from unittest.mock import MagicMock, patch

# ───────────────────── import the storage module ─────────────────────── #
postgres: ModuleType = importlib.import_module(
    "lib.collectors.sevenps.storage.postgres"
)

# ──────────────────── lightweight fake psycopg-pool ───────────────────── #
class FakeConn(MagicMock):
    """Mock connection whose cursor is also a context-manager."""
    def __init__(self):
        super().__init__(name="connection")
        cur = MagicMock(name="cursor")
        cur.__enter__.return_value = cur
        cur.__exit__.return_value = None
        self.cursor.return_value = cur
        self.commit = MagicMock()
        self.rollback = MagicMock()

class FakePool:
    """Drop-in for psycopg_pool.ConnectionPool."""
    def __init__(self, conninfo: str, **_):
        self.conninfo = conninfo          # constructor logs this
        self.conn = FakeConn()
        self.put_calls = 0
        self.closed = False

    # Legacy API used by store_test_set_data_async
    def getconn(self):
        return self.conn

    def putconn(self, _):
        self.put_calls += 1

    # Context-manager API used by get_test_set_data
    @contextmanager
    def connection(self):
        try:
            yield self.conn
        finally:
            self.putconn(self.conn)

    # Graceful-shutdown helpers
    def close(self): self.closed = True
    def join(self):  ...

# Ensure postgres.psycopg.UniqueViolation exists even if psycopg is absent
if not hasattr(postgres.psycopg, "UniqueViolation"):
    class _FakeUV(Exception): ...
    postgres.psycopg.UniqueViolation = _FakeUV


# ───────────────────────────── TESTS ──────────────────────────────────── #
class TestPostgresDBStorage(unittest.TestCase):
    def setUp(self):
        # Replace the pool class _inside the already-imported module_
        self.pool_patch = patch.object(postgres, "ConnectionPool", FakePool)
        self.pool_patch.start()

        # Force LOCAL branch in _get_conn_info
        with patch.dict(os.environ, {"CLOUD": "false"}):
            self.storage = postgres.PostgresDBStorage({"min_connections": 1})

        self.pool = self.storage.conn_pool
        self.conn = self.pool.conn
        self.cur = self.conn.cursor.return_value

    def tearDown(self):
        self.pool_patch.stop()

    # ──────────── store_test_set_data_async paths ────────────────────── #
    @patch("time.sleep", return_value=None)
    def test_store_success(self, _):
        record = {k: "1" for k in (
            "repo_url", "artifact_url", "artifact_name", "artifact_version",
            "test_set_type", "test_request_id", "component_asv", "component_bap",
            "report_doc", "report_source", "traceability_doc",
            "github_org", "github_repo", "github_branch",
            "pr_url", "pr_id_branch", "pr_source_branch",
            "build_id", "test_type_details", "test_run_status")}
        self.storage.store_test_set_data_async([record])

        self.cur.execute.assert_called_once()
        self.conn.commit.assert_called_once()
        self.assertEqual(self.pool.put_calls, 1)

    @patch("time.sleep", return_value=None)
    def test_store_unique_violation(self, _):
        self.cur.execute.side_effect = postgres.psycopg.UniqueViolation("dup")
        with self.assertRaises(postgres.psycopg.UniqueViolation):
            self.storage.store_test_set_data_async([{"artifact_url": "dup"}])

        self.conn.rollback.assert_called_once()
        self.assertEqual(self.pool.put_calls, 1)

    @patch("time.sleep", return_value=None)
    def test_store_retry_then_database_error(self, _):
        self.cur.execute.side_effect = Exception("boom")
        with self.assertRaises(postgres.DatabaseError):
            self.storage.store_test_set_data_async([{"artifact_url": "x"}])

        # 6→0 retries  ⇒ 7 rollbacks / returns
        self.assertEqual(self.conn.rollback.call_count, 7)
        self.assertEqual(self.pool.put_calls, 7)

    def test_store_empty_input(self):
        with self.assertRaises(ValueError):
            self.storage.store_test_set_data_async([])

    # ──────────── get_test_set_data paths ────────────────────────────── #
    def test_get_data_found(self):
        self.cur.fetchall.return_value = [("json-value",)]
        self.assertEqual(
            self.storage.get_test_set_data(artifact_id="1"), ["json-value"])
        self.assertEqual(self.pool.put_calls, 1)

    def test_get_data_not_found(self):
        self.cur.fetchall.return_value = []
        with self.assertRaises(postgres.RecordNotFoundException):
            self.storage.get_test_set_data(test_request_id="none")
        self.assertEqual(self.pool.put_calls, 1)

    def test_get_data_bad_args(self):
        with self.assertRaises(ValueError):
            self.storage.get_test_set_data()

    # ──────────── _get_conn_info cloud branch ────────────────────────── #
    def test_get_conn_info_cloud(self):
        env = {"CLOUD": "true", "DB_APP_USERNAME": "u", "DB_APP_PASSWORD": "p",
               "DB_HOST": "h", "DATABASE": "d"}
        with patch.dict(os.environ, env):
            info = postgres.PostgresDBStorage({"min_connections": 1})._get_conn_info()
        self.assertIn("host=h", info)

    # ──────────── constructor failure branch ─────────────────────────── #
    def test_init_failure(self):
        with patch.object(postgres, "ConnectionPool", side_effect=Exception):
            with self.assertRaises(postgres.DatabaseConnectionError):
                postgres.PostgresDBStorage({})

    # ──────────── graceful shutdown / stopped() ──────────────────────── #
    def test_close_and_stopped(self):
        self.storage.close()
        self.assertTrue(self.pool.closed)
        self.storage.stopped()   # second close is a harmless no-op


if __name__ == "__main__":  # pragma: no cover
    unittest.main(verbosity=2)
