# tests/test_db_final.py
import asyncio
import importlib
import types
import unittest
from unittest.mock import AsyncMock, patch

# ---------------------------------------------------------------------------
# Discover the real postgres module (works for either package layout)
# ---------------------------------------------------------------------------
try:
    postgres = importlib.import_module("lib.collectors.sevenps.storage.postgres")
    PATCH_ROOT = "lib.collectors.sevenps.storage.postgres"
except ModuleNotFoundError:
    postgres = importlib.import_module("lib.collectors.sevenps.postgres")
    PATCH_ROOT = "lib.collectors.sevenps.postgres"


# ---------------------------------------------------------------------------
# Helpers to fabricate a psycopg-like async connection-pool
# ---------------------------------------------------------------------------
def _make_pool(*, closed=True):
    """
    Return (pool, cursor) where `pool` is an AsyncMock that mimics
    psycopg.pool.AsyncConnectionPool well enough for unit-testing.
    """
    pool = AsyncMock()
    pool.closed = closed
    pool.open = AsyncMock()
    pool.close = AsyncMock()

    cursor = AsyncMock()
    cursor.execute = AsyncMock()
    cursor.fetchall = AsyncMock()

    # connection context-manager ------------------------------------------------
    conn_cm = AsyncMock()
    conn_cm.commit = AsyncMock()
    # cursor() returns its own async-context manager
    cursor_cm = AsyncMock()
    cursor_cm.__aenter__.return_value = cursor
    cursor_cm.__aexit__.return_value = False
    conn_cm.cursor.return_value = cursor_cm

    # pool.connection() → async-ctx manager
    conn_outer_cm = AsyncMock()
    conn_outer_cm.__aenter__.return_value = conn_cm
    conn_outer_cm.__aexit__.return_value = False
    pool.connection.return_value = conn_outer_cm

    return pool, cursor


# ---------------------------------------------------------------------------
# The test-suite
# ---------------------------------------------------------------------------
class TestPostgresDBStorage(unittest.IsolatedAsyncioTestCase):
    # ───────────────────────── constructor ──────────────────────────
    @patch(f"{PATCH_ROOT}.AsyncConnectionPool")
    @patch(f"{PATCH_ROOT}.os.getenv", return_value="LOCAL")
    async def test_init_local_success(self, _mock_getenv, mock_pool_cls):
        cfg = {"min_connections": 1, "max_connections": 2}
        postgres.PostgresDBStorage(cfg)
        mock_pool_cls.assert_called_once()           # pool factory invoked

    @patch(f"{PATCH_ROOT}.AsyncConnectionPool", side_effect=Exception("boom"))
    @patch(f"{PATCH_ROOT}.os.getenv", return_value="CLOUD")
    async def test_init_cloud_failure(self, _mock_getenv, _mock_pool_cls):
        with self.assertRaises(postgres.DatabaseConnectionError):
            postgres.PostgresDBStorage({})

    # ─────────────────── ensure_pool_open / close ───────────────────
    async def test_pool_open_and_close(self):
        pool, _ = _make_pool(closed=True)
        storage = types.SimpleNamespace(conn_pool=pool)
        storage._ensure_pool_open = postgres.PostgresDBStorage._ensure_pool_open.__get__(storage)
        storage.close = postgres.PostgresDBStorage.close.__get__(storage)

        await storage._ensure_pool_open()
        pool.open.assert_awaited_once()

        pool.closed = False
        await storage._ensure_pool_open()            # no 2nd open
        pool.open.assert_awaited_once()

        await storage.close()
        pool.close.assert_awaited_once()

    # ───────────────────────── _execute ─────────────────────────────
    @patch(f"{PATCH_ROOT}.PostgresDBStorage._ensure_pool_open", new_callable=AsyncMock)
    async def test_execute_success(self, _mock_ensure):
        pool, cursor = _make_pool(closed=False)
        storage = types.SimpleNamespace(conn_pool=pool)
        storage._execute = postgres.PostgresDBStorage._execute.__get__(storage)

        await storage._execute("INSERT X", {"p": 1})
        cursor.execute.assert_awaited_once_with("INSERT X", {"p": 1})
        pool.connection.return_value.__aenter__.return_value.commit.assert_awaited_once()

    @patch(f"{PATCH_ROOT}.PostgresDBStorage._ensure_pool_open", new_callable=AsyncMock)
    async def test_execute_failure(self, _mock_ensure):
        pool, cursor = _make_pool(closed=False)
        cursor.execute.side_effect = Exception("bad sql")

        storage = types.SimpleNamespace(conn_pool=pool)
        storage._execute = postgres.PostgresDBStorage._execute.__get__(storage)

        with self.assertRaises(Exception):
            await storage._execute("oops")

    # ───────────────────────── _fetch_all ───────────────────────────
    @patch(f"{PATCH_ROOT}.PostgresDBStorage._ensure_pool_open", new_callable=AsyncMock)
    async def test_fetch_all(self, _mock_ensure):
        pool, cursor = _make_pool(closed=False)
        cursor.fetchall.return_value = [(1,), (2,)]

        storage = types.SimpleNamespace(conn_pool=pool)
        storage._fetch_all = postgres.PostgresDBStorage._fetch_all.__get__(storage)

        rows = await storage._fetch_all("SELECT 1")
        self.assertEqual(rows, [(1,), (2,)])

    # ──────────────── store_test_set_data branches ─────────────────
    async def test_store_test_set_data_value_error(self):
        pool, _ = _make_pool(closed=False)
        storage = types.SimpleNamespace(conn_pool=pool)
        storage.store_test_set_data = postgres.PostgresDBStorage.store_test_set_data.__get__(storage)
        with self.assertRaises(ValueError):
            await storage.store_test_set_data([])

    @patch(f"{PATCH_ROOT}.errors.UniqueViolation", new=Exception)  # simple alias
    async def test_store_test_set_data_success(self):
        pool, _ = _make_pool(closed=False)
        storage = types.SimpleNamespace(conn_pool=pool)
        storage.store_test_set_data = postgres.PostgresDBStorage.store_test_set_data.__get__(storage)

        good_record = {
            "repo_url": "r", "artifact_url": "a", "artifact_name": "n",
            "artifact_version": "v", "test_set_type": "type",
            "test_request_id": "req", "component_asv": 1, "component_bap": 2,
            "report_doc": None, "report_source": None, "traceability_doc": None,
            "github_org": "o", "github_repo": "p", "github_branch": "b",
            "pr_url": "u", "pr_id_branch": "idb", "pr_source_branch": "src",
            "build_id": "bid", "test_type_details": "det", "test_run_status": "S",
        }
        await storage.store_test_set_data([good_record])  # should not raise

    # ────────────────── get_test_set_data branches ─────────────────
    async def _setup_get(self):
        pool, cursor = _make_pool(closed=False)
        storage = types.SimpleNamespace(conn_pool=pool)
        storage.get_test_set_data = postgres.PostgresDBStorage.get_test_set_data.__get__(storage)
        return storage, cursor

    async def test_get_test_set_data_artifact(self):
        storage, cursor = await self._setup_get()
        cursor.fetchall.return_value = [("j1",), ("j2",)]
        out = await storage.get_test_set_data(artifact_id="A1")
        self.assertEqual(out, ["j1", "j2"])

    async def test_get_test_set_data_none_found(self):
        storage, cursor = await self._setup_get()
        cursor.fetchall.return_value = []
        with self.assertRaises(postgres.RecordNotFoundException):
            await storage.get_test_set_data(test_request_id="T1")

    # ───────────────────────── stopped() ───────────────────────────
    async def test_stopped(self):
        pool, _ = _make_pool(closed=False)
        storage = types.SimpleNamespace(conn_pool=pool)
        storage.stopped = postgres.PostgresDBStorage.stopped.__get__(storage)
        await storage.stopped()
        pool.close.assert_awaited_once()
