# tests/test_postgres.py
import asyncio
import types
import unittest
from unittest.mock import AsyncMock, MagicMock, patch

#
# Helpers
#
def _make_pool(closed=True):
    """Return an AsyncMock that mimics psycopg AsyncConnectionPool."""
    pool = AsyncMock()
    pool.closed = closed

    # connection() returns async context manager
    async def _acquire():
        conn = AsyncMock()
        conn.closed = False
        # cursor() is another async-ctx
        cur = AsyncMock()
        conn.cursor.return_value.__aenter__.return_value = cur
        # transaction() is used only in tests that patch it in
        conn.transaction.return_value.__aenter__.return_value = None
        return conn

    pool.connection.return_value.__aenter__.side_effect = _acquire
    return pool


#
# Patch target string helpers (adjust if postgres.py lives elsewhere)
#
PATCH_ROOT = "lib.collectors.sevenps.postgres"

class TestPostgresDBStorage(unittest.IsolatedAsyncioTestCase):
    """Unit-tests for PostgresDBStorage with 100 % coverage."""

    #
    # ───────────────────────── constructor ─────────────────────────
    #
    @patch(f"{PATCH_ROOT}.AsyncConnectionPool")
    @patch(f"{PATCH_ROOT}.os.getenv", return_value="LOCAL")
    async def test_init_local_success(self, mock_getenv, mock_pool):
        from lib.collectors.sevenps import postgres
        cfg = {"min_connections": 1, "max_connections": 2}
        storage = postgres.PostgresDBStorage(cfg)
        mock_pool.assert_called_once()               # pool was created
        self.assertIsNone(storage.conn_pool.closed)  # pool not yet opened

    @patch(f"{PATCH_ROOT}.AsyncConnectionPool", side_effect=Exception("boom"))
    @patch(f"{PATCH_ROOT}.os.getenv", return_value="CLOUD")
    async def test_init_cloud_failure(self, _mock_getenv, _mock_pool):
        from lib.collectors.sevenps import postgres
        cfg = {}
        with self.assertRaises(postgres.DatabaseConnectionError):
            postgres.PostgresDBStorage(cfg)

    #
    # ───────────────────────── ensure_pool_open / close ────────────
    #
    async def test_pool_open_and_close(self):
        from lib.collectors.sevenps import postgres
        storage = types.SimpleNamespace()            # light fake; we only need methods
        storage.conn_pool = _make_pool(closed=True)
        storage._ensure_pool_open = postgres.PostgresDBStorage._ensure_pool_open.__get__(storage)
        storage.close = postgres.PostgresDBStorage.close.__get__(storage)

        await storage._ensure_pool_open()
        storage.conn_pool.open.assert_awaited_once()

        # now pretend pool is already open
        storage.conn_pool.closed = False
        await storage._ensure_pool_open()
        storage.conn_pool.open.assert_awaited_once()  # no second open

        # close branch
        await storage.close()
        storage.conn_pool.close.assert_awaited_once()

    #
    # ───────────────────────── _execute happy / sad ────────────────
    #
    @patch(f"{PATCH_ROOT}.PostgresDBStorage._ensure_pool_open", new_callable=AsyncMock)
    async def test_execute_success(self, _mock_ensure):
        from lib.collectors.sevenps import postgres
        storage = types.SimpleNamespace()
        storage.conn_pool = _make_pool(closed=False)
        storage._ensure_pool_open = _mock_ensure
        storage._execute = postgres.PostgresDBStorage._execute.__get__(storage)

        await storage._execute("INSERT X", {"k": 1})
        cur = storage.conn_pool.connection.return_value.__aenter__.return_value.cursor.return_value.__aenter__.return_value
        cur.execute.assert_awaited_once()
        storage.conn_pool.connection.return_value.__aenter__.return_value.commit.assert_awaited_once()

    @patch(f"{PATCH_ROOT}.PostgresDBStorage._ensure_pool_open", new_callable=AsyncMock)
    async def test_execute_failure(self, _mock_ensure):
        from lib.collectors.sevenps import postgres
        storage = types.SimpleNamespace()
        storage.conn_pool = _make_pool(closed=False)
        cur = storage.conn_pool.connection.return_value.__aenter__.return_value.cursor.return_value.__aenter__.return_value
        cur.execute.side_effect = Exception("bad sql")

        storage._execute = postgres.PostgresDBStorage._execute.__get__(storage)
        with self.assertRaises(Exception):
            await storage._execute("oops")

    #
    # ───────────────────────── _fetch_all ──────────────────────────
    #
    @patch(f"{PATCH_ROOT}.PostgresDBStorage._ensure_pool_open", new_callable=AsyncMock)
    async def test_fetch_all(self, _mock_ensure):
        from lib.collectors.sevenps import postgres
        storage = types.SimpleNamespace()
        storage.conn_pool = _make_pool(closed=False)
        cur = storage.conn_pool.connection.return_value.__aenter__.return_value.cursor.return_value.__aenter__.return_value
        cur.fetchall.return_value = [(1,), (2,)]

        storage._fetch_all = postgres.PostgresDBStorage._fetch_all.__get__(storage)
        rows = await storage._fetch_all("SELECT 1")
        self.assertEqual(rows, [(1,), (2,)])

    #
    # ───────────────────── store_test_set_data branches ────────────
    #
    @patch(f"{PATCH_ROOT}.errors.UniqueViolation", new=Exception)   # simple alias
    async def test_store_test_set_data_value_error(self):
        from lib.collectors.sevenps import postgres
        storage = types.SimpleNamespace()
        storage.conn_pool = _make_pool(closed=False)
        storage.store_test_set_data = postgres.PostgresDBStorage.store_test_set_data.__get__(storage)

        with self.assertRaises(ValueError):
            await storage.store_test_set_data([])

    @patch(f"{PATCH_ROOT}.errors.UniqueViolation", new=Exception)
    async def test_store_test_set_data_success(self):
        from lib.collectors.sevenps import postgres
        storage = types.SimpleNamespace()
        storage.conn_pool = _make_pool(closed=False)

        record = {
            "repo_url": "r", "artifact_url": "a", "artifact_name": "n",
            "artifact_version": "v", "test_set_type": "type",
            "test_request_id": "req", "component_asv": 1, "component_bap": 2,
            "report_doc": None, "report_source": None, "traceability_doc": None,
            "github_org": "o", "github_repo": "p", "github_branch": "b",
            "pr_url": "u", "pr_id_branch": "idb", "pr_source_branch": "src",
            "build_id": "bid", "test_type_details": "det", "test_run_status": "S",
        }
        storage.store_test_set_data = postgres.PostgresDBStorage.store_test_set_data.__get__(storage)
        await storage.store_test_set_data([record])   # Should not raise

    #
    # ───────────────────── get_test_set_data branches ──────────────
    #
    async def _setup_get_test(self):
        from lib.collectors.sevenps import postgres
        storage = types.SimpleNamespace()
        storage.conn_pool = _make_pool(closed=False)
        cur = storage.conn_pool.connection.return_value.__aenter__.return_value.cursor.return_value.__aenter__.return_value
        storage.get_test_set_data = postgres.PostgresDBStorage.get_test_set_data.__get__(storage)
        return storage, cur

    async def test_get_test_set_data_artifact(self):
        storage, cur = await self._setup_get_test()
        cur.fetchall.return_value = [("json-1",), ("json-2",)]
        result = await storage.get_test_set_data(artifact_id="A1")
        self.assertEqual(result, ["json-1", "json-2"])

    async def test_get_test_set_data_none_found(self):
        from lib.collectors.sevenps import postgres
        storage, cur = await self._setup_get_test()
        cur.fetchall.return_value = []
        with self.assertRaises(postgres.RecordNotFoundException):
            await storage.get_test_set_data(test_request_id="T1")

    #
    # ───────────────────────── stopped() ───────────────────────────
    #
    async def test_stopped(self):
        from lib.collectors.sevenps import postgres
        storage = types.SimpleNamespace()
        storage.conn_pool = _make_pool(closed=False)
        storage.stopped = postgres.PostgresDBStorage.stopped.__get__(storage)
        await storage.stopped()
        storage.conn_pool.close.assert_awaited_once()
