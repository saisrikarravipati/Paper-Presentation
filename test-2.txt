"""
tests/test_db.py
────────────────
100 % coverage for postgres.PostgresDBStorage – with minimal test scaffolding.
"""
from __future__ import annotations

import importlib
import os
import unittest
from unittest.mock import MagicMock, patch


# ──────────────── tiny fake pool so no real DB is needed ──────────────── #
class FakePool:
    def __init__(self, *_, **__):
        self.conn = MagicMock(name="connection")
        self.closed = False

    def getconn(self):
        return self.conn

    def putconn(self, _):
        self.put_count = getattr(self, "put_count", 0) + 1

    def close(self):
        self.closed = True

    def join(self):
        pass


# ───────────── import postgres with the pool patched in place ──────────── #
with patch("psycopg_pool.ConnectionPool", FakePool):
    postgres = importlib.import_module("postgres")  # imported once under patch


# ──────────────────────────── TESTS ────────────────────────────────────── #
class TestPostgresDBStorage(unittest.TestCase):
    def setUp(self):
        with patch.dict(os.environ, {"CLOUD": "false"}):
            self.storage = postgres.PostgresDBStorage({"min_connections": 1})

        self.pool = self.storage.conn_pool
        self.conn = self.pool.conn
        self.cur = self.conn.cursor.return_value

    # ------- happy path -------------------------------------------------- #
    @patch("postgres.time.sleep", return_value=None)
    def test_store_success(self, _):
        record = {k: "x" for k in (
            "repo_url", "artifact_url", "artifact_name", "artifact_version",
            "test_set_type", "test_request_id", "component_asv", "component_bap",
            "report_doc", "report_source", "traceability_doc",
            "github_org", "github_repo", "github_branch",
            "pr_url", "pr_id_branch", "pr_source_branch",
            "build_id", "test_type_details", "test_run_status")}
        self.storage.store_test_set_data_async([record])

        self.cur.execute.assert_called_once()
        self.conn.commit.assert_called_once()
        self.assertEqual(self.pool.put_count, 1)

    # ------- UniqueViolation branch ------------------------------------- #
    @patch("postgres.time.sleep", return_value=None)
    def test_store_unique_violation(self, _):
        self.cur.execute.side_effect = postgres.psycopg.UniqueViolation("dup")
        with self.assertRaises(postgres.psycopg.UniqueViolation):
            self.storage.store_test_set_data_async([{"artifact_url": "dup"}])

        self.conn.rollback.assert_called_once()
        self.assertEqual(self.pool.put_count, 1)

    # ------- retry until DatabaseError branch --------------------------- #
    @patch("postgres.time.sleep", return_value=None)
    def test_store_generic_failure(self, _):
        self.cur.execute.side_effect = Exception("boom")
        with self.assertRaises(postgres.DatabaseError):
            self.storage.store_test_set_data_async([{"artifact_url": "bad"}])

        self.assertEqual(self.conn.rollback.call_count, 7)   # 6→0 retries
        self.assertEqual(self.pool.put_count, 7)

    # ------- guard: empty input ----------------------------------------- #
    def test_store_empty_records(self):
        with self.assertRaises(ValueError):
            self.storage.store_test_set_data_async([])

    # ------- read API paths --------------------------------------------- #
    def test_get_test_set_data_found(self):
        self.cur.fetchall.return_value = [("json",)]
        self.assertEqual(
            self.storage.get_test_set_data(artifact_id="1"), ["json"]
        )

    def test_get_test_set_data_not_found(self):
        self.cur.fetchall.return_value = []
        with self.assertRaises(postgres.RecordNotFoundException):
            self.storage.get_test_set_data(test_request_id="none")

    def test_get_test_set_data_bad_args(self):
        with self.assertRaises(ValueError):
            self.storage.get_test_set_data()

    # ------- _get_conn_info cloud branch -------------------------------- #
    def test_get_conn_info_cloud(self):
        env = {
            "CLOUD": "true", "DB_APP_USERNAME": "u", "DB_APP_PASSWORD": "p",
            "DB_HOST": "h", "DATABASE": "d"}
        with patch.dict(os.environ, env):
            info = postgres.PostgresDBStorage({"min_connections": 1})._get_conn_info()
        self.assertIn("host=h", info)

    # ------- constructor failure branch --------------------------------- #
    def test_init_failure(self):
        with patch("psycopg_pool.ConnectionPool", side_effect=Exception):
            with self.assertRaises(postgres.DatabaseConnectionError):
                importlib.reload(postgres).PostgresDBStorage({})

    # ------- graceful shutdown ------------------------------------------ #
    def test_close_and_stopped(self):
        self.storage.close()
        self.assertTrue(self.pool.closed)
        self.storage.stopped()  # second close – should be harmless


if __name__ == "__main__":  # pragma: no cover
    unittest.main(verbosity=2)
