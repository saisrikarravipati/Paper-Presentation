import asyncio
import unittest
from unittest.mock import AsyncMock, MagicMock, patch

from lib.collectors.sevenps.storage.postgres import (
    DatabaseConnectionError,
    PostgresDBStorage,
    RecordNotFoundException,
)

PATCH_ROOT = "lib.collectors.sevenps.storage.postgres"


# ───────────────────────────── helpers ───────────────────────────── #

def _make_fake_pool(closed: bool = True):
    """
    Build (fake_pool, fake_cursor) such that the real psycopg semantics are
    reproduced closely:

      • pool.connection()  → *returns* an **async context-manager** (not a coroutine)
      • conn.cursor()      → idem
      • .open/.close/.commit/.execute/.fetchall are awaitables (AsyncMock)
    """
    fake_pool = MagicMock()
    fake_pool.closed = closed
    fake_pool.open = AsyncMock()
    fake_pool.close = AsyncMock()

    # connection CM
    fake_conn = MagicMock()
    fake_conn.commit = AsyncMock()

    conn_cm = MagicMock()
    conn_cm.__aenter__ = AsyncMock(return_value=fake_conn)
    conn_cm.__aexit__ = AsyncMock(return_value=False)
    fake_pool.connection = MagicMock(return_value=conn_cm)

    # cursor CM
    fake_cursor = MagicMock()
    fake_cursor.execute = AsyncMock()
    fake_cursor.fetchall = AsyncMock()

    cur_cm = MagicMock()
    cur_cm.__aenter__ = AsyncMock(return_value=fake_cursor)
    cur_cm.__aexit__ = AsyncMock(return_value=False)
    fake_conn.cursor = MagicMock(return_value=cur_cm)

    return fake_pool, fake_cursor


# ───────────────────────────── tests ────────────────────────────── #

class TestPostgresDBStorage(unittest.TestCase):
    # ------------- constructor paths ------------- #

    @patch(f"{PATCH_ROOT}.AsyncConnectionPool")
    @patch(f"{PATCH_ROOT}.os.getenv", return_value="LOCAL")
    @patch(f"{PATCH_ROOT}.asyncio.run_coroutine_threadsafe")
    def test_init_local_success(self, m_run_tc, _m_env, m_pool_cls):
        fake_pool, _ = _make_fake_pool(closed=True)
        m_pool_cls.return_value = fake_pool

        class DummyFuture:
            def result(self):
                return None

        m_run_tc.return_value = DummyFuture()

        PostgresDBStorage({"min_connections": 1, "max_connections": 2})

        m_pool_cls.assert_called_once()
        self.assertTrue(m_run_tc.called)

    @patch(f"{PATCH_ROOT}.AsyncConnectionPool", side_effect=Exception("boom"))
    @patch(f"{PATCH_ROOT}.os.getenv", return_value="CLOUD")
    @patch(f"{PATCH_ROOT}.asyncio.run_coroutine_threadsafe")
    def test_init_cloud_failure(self, _m_run_tc, _m_env, _m_pool_cls):
        with self.assertRaises(DatabaseConnectionError):
            PostgresDBStorage({})

    # -------- ensure_pool_open_async / _close_pool ---------- #

    def test_pool_open_and_close_coroutines(self):
        fake_pool, _ = _make_fake_pool(closed=True)
        storage = PostgresDBStorage.__new__(PostgresDBStorage)
        storage._pool = fake_pool

        ensure_coro = PostgresDBStorage._ensure_pool_open_async.__get__(storage)
        close_coro = PostgresDBStorage._close_pool.__get__(storage)

        loop = asyncio.new_event_loop()
        loop.run_until_complete(ensure_coro())
        loop.close()
        fake_pool.open.assert_awaited_once()

        fake_pool.closed = False
        fake_pool.open.reset_mock()
        loop = asyncio.new_event_loop()
        loop.run_until_complete(ensure_coro())
        loop.close()
        fake_pool.open.assert_not_awaited()

        loop = asyncio.new_event_loop()
        loop.run_until_complete(close_coro())
        loop.close()
        fake_pool.close.assert_awaited_once()

    # ----------------------- _execute ----------------------- #

    @patch(f"{PATCH_ROOT}.asyncio.run_coroutine_threadsafe")
    def test_execute_success(self, m_run_tc):
        fake_pool, fake_cursor = _make_fake_pool(closed=False)
        storage = PostgresDBStorage.__new__(PostgresDBStorage)
        storage._pool = fake_pool
        storage._loop = asyncio.new_event_loop()

        class DummyFuture:
            def __init__(self, val):
                self._val = val

            def result(self):
                return self._val

        def fake_run(coro, loop):
            runner = asyncio.new_event_loop()
            res = runner.run_until_complete(coro)
            runner.close()
            return DummyFuture(res)

        m_run_tc.side_effect = fake_run

        storage._execute("INSERT INTO xyz(id) VALUES(%s)", {"id": 1})
        fake_cursor.execute.assert_awaited_once_with(
            "INSERT INTO xyz(id) VALUES(%s)", {"id": 1}
        )
        fake_pool.connection.return_value.__aenter__.return_value.commit.assert_awaited_once()

    @patch(f"{PATCH_ROOT}.asyncio.run_coroutine_threadsafe")
    def test_execute_failure(self, m_run_tc):
        fake_pool, fake_cursor = _make_fake_pool(closed=False)
        fake_cursor.execute.side_effect = Exception("boom")

        storage = PostgresDBStorage.__new__(PostgresDBStorage)
        storage._pool = fake_pool
        storage._loop = asyncio.new_event_loop()

        class DummyFuture:
            def __init__(self, res_or_exc):
                self._res = res_or_exc

            def result(self):
                if isinstance(self._res, Exception):
                    raise self._res
                return self._res

        def fake_run(coro, loop):
            runner = asyncio.new_event_loop()
            try:
                res = runner.run_until_complete(coro)
                return DummyFuture(res)
            except Exception as e:
                return DummyFuture(e)
            finally:
                runner.close()

        m_run_tc.side_effect = fake_run

        with self.assertRaises(Exception):
            storage._execute("INSERT BAD", None)

    # --------------------- fetch_all ----------------------- #

    @patch(f"{PATCH_ROOT}.asyncio.run_coroutine_threadsafe")
    def test_fetch_all(self, m_run_tc):
        fake_pool, fake_cursor = _make_fake_pool(closed=False)
        fake_cursor.fetchall.return_value = [(1,), (2,)]

        storage = PostgresDBStorage.__new__(PostgresDBStorage)
        storage._pool = fake_pool
        storage._loop = asyncio.new_event_loop()

        class DummyFuture:
            def __init__(self, val):
                self._val = val

            def result(self):
                return self._val

        def fake_run(coro, loop):
            runner = asyncio.new_event_loop()
            res = runner.run_until_complete(coro)
            runner.close()
            return DummyFuture(res)

        m_run_tc.side_effect = fake_run
        rows = storage.fetch_all("SELECT * FROM foo", None)
        self.assertEqual(rows, [(1,), (2,)])

    # -------- store_test_set_data edge + happy paths -------- #

    @patch(f"{PATCH_ROOT}.asyncio.run_coroutine_threadsafe")
    def test_store_test_set_data_value_error(self, _m_run_tc):
        fake_pool, _ = _make_fake_pool(closed=False)
        storage = PostgresDBStorage.__new__(PostgresDBStorage)
        storage._pool = fake_pool
        storage._loop = asyncio.new_event_loop()
        with self.assertRaises(ValueError):
            storage.store_test_set_data([])

    @patch(f"{PATCH_ROOT}.asyncio.run_coroutine_threadsafe")
    def test_store_test_set_data_success(self, m_run_tc):
        fake_pool, fake_cursor = _make_fake_pool(closed=False)

        storage = PostgresDBStorage.__new__(PostgresDBStorage)
        storage._pool = fake_pool
        storage._loop = asyncio.new_event_loop()

        class DummyFuture:
            def __init__(self, val):
                self._val = val

            def result(self):
                return self._val

        def fake_run(coro, loop):
            runner = asyncio.new_event_loop()
            res = runner.run_until_complete(coro)
            runner.close()
            return DummyFuture(res)

        m_run_tc.side_effect = fake_run

        record = {k: "x" for k in (
            "repo_url", "artifact_url", "artifact_name", "artifact_version",
            "test_set_type", "test_request_id", "component_asv", "component_bap",
            "report_doc", "report_source", "traceability_doc",
            "github_org", "github_repo", "github_branch",
            "pr_url", "pr_id_branch", "pr_source_branch",
            "build_id", "test_type_details", "test_run_status"
        )}
        storage.store_test_set_data([record])
        self.assertTrue(fake_cursor.execute.await_count >= 1)

    # ---------------------- get_test_set_data --------------------- #

    @patch(f"{PATCH_ROOT}.asyncio.run_coroutine_threadsafe")
    def test_get_test_set_data_artifact_success(self, m_run_tc):
        fake_pool, fake_cursor = _make_fake_pool(closed=False)
        fake_cursor.fetchall.return_value = [("json-1",), ("json-2",)]

        storage = PostgresDBStorage.__new__(PostgresDBStorage)
        storage._pool = fake_pool
        storage._loop = asyncio.new_event_loop()

        class DummyFuture:
            def __init__(self, val):
                self._val = val

            def result(self):
                return self._val

        def fake_run(coro, loop):
            runner = asyncio.new_event_loop()
            res = runner.run_until_complete(coro)
            runner.close()
            return DummyFuture(res)

        m_run_tc.side_effect = fake_run
        out = storage.get_test_set_data(artifact_id="A-1")
        self.assertEqual(out, ["json-1", "json-2"])

    @patch(f"{PATCH_ROOT}.asyncio.run_coroutine_threadsafe")
    def test_get_test_set_data_not_found(self, m_run_tc):
        fake_pool, fake_cursor = _make_fake_pool(closed=False)
        fake_cursor.fetchall.return_value = []

        storage = PostgresDBStorage.__new__(PostgresDBStorage)
        storage._pool = fake_pool
        storage._loop = asyncio.new_event_loop()

        class DummyFuture:
            def __init__(self, res_or_exc):
                self._res = res_or_exc

            def result(self):
                if isinstance(self._res, Exception):
                    raise self._res
                return self._res

        def fake_run(coro, loop):
            runner = asyncio.new_event_loop()
            try:
                res = runner.run_until_complete(coro)
                return DummyFuture(res)
            except Exception as e:
                return DummyFuture(e)
            finally:
                runner.close()

        m_run_tc.side_effect = fake_run
        with self.assertRaises(RecordNotFoundException):
            storage.get_test_set_data(test_request_id="T-1")

    # -------------------------- close() -------------------------- #

    @patch(f"{PATCH_ROOT}.asyncio.run_coroutine_threadsafe")
    def test_close(self, m_run_tc):
        fake_pool, _ = _make_fake_pool(closed=False)

        storage = PostgresDBStorage.__new__(PostgresDBStorage)
        storage._pool = fake_pool
        storage._loop = asyncio.new_event_loop()
        storage._thread = MagicMock()

        class DummyFuture:
            def __init__(self, val):
                self._val = val

            def result(self):
                return self._val

        def fake_run(coro, loop):
            runner = asyncio.new_event_loop()
            res = runner.run_until_complete(coro)
            runner.close()
            return DummyFuture(res)

        m_run_tc.side_effect = fake_run
        storage.close()

        fake_pool.close.assert_awaited_once()
        storage._thread.join.assert_called()


if __name__ == "__main__":
    unittest.main()
