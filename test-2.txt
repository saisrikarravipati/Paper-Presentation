# ➊ Add these imports with the rest
from unittest.mock import call

# --------------------------------------------------------------------------- #
# ➋ NEW tests – append to the end of TestPostgresDBStorage                     #
# --------------------------------------------------------------------------- #
    def test_store_retry_then_success(self):
        """First execute() raises generic Error, second succeeds – ensures retry path."""
        # cursor raises once, then works
        first = MagicMock(side_effect=Exception("temp"))
        second = MagicMock()
        retry_cursor = _make_cursor()
        retry_cursor.execute.side_effect = [Exception("temp"), None]
        retry_conn = _make_connection(retry_cursor)
        self.mock_pool.getconn.return_value = retry_conn

        storage = postgres.PostgresDBStorage({})
        storage.store_test_set_data([self.SAMPLE_RECORD])

        # execute was tried twice, commit once
        self.assertEqual(retry_cursor.execute.call_count, 2)
        retry_conn.commit.assert_called_once()

    def test_get_conn_info_cloud(self):
        """_get_conn_info’s CLOUD branch creates a DSN containing env variables."""
        with patch.dict(os.environ, CLOUD="true", DB_APP_USERNAME="u",
                        DB_APP_PASSWORD="p", DB_HOST="h", DATABASE="d"):
            # ConnectionPool is already patched – just create the object
            storage = postgres.PostgresDBStorage({})
            dsn = storage._get_conn_info()
            self.assertIn("user=u", dsn)
            self.assertIn("password=p", dsn)
            self.assertIn("host=h", dsn)
            self.assertIn("dbname=d", dsn)

    def test_close_handles_exception(self):
        """close() logs but continues when pool.close throws."""
        self.mock_pool.close.side_effect = Exception("socket error")
        storage = postgres.PostgresDBStorage({})
        # Should not raise
        storage.close()
        self.mock_pool.join.assert_called_once()
