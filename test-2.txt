# tests/test_db.py
# … keep the header exactly as before …

def _make_fake_pool(closed: bool = True):
    """
    Build `(fake_pool, fake_cursor)` such that:

    ● The very first `cursor()` call (originating from the health-check)
      yields its own mock cursor.
    ● The second and subsequent `cursor()` calls yield a *different*
      mock cursor that we return to the caller as `fake_cursor`.
    """
    fake_pool = MagicMock()
    fake_pool.closed = closed
    fake_pool.open = AsyncMock()
    fake_pool.close = AsyncMock()

    # ---------- connection CM ----------
    fake_conn = MagicMock()
    fake_conn.commit = AsyncMock()

    conn_cm = MagicMock()
    conn_cm.__aenter__ = AsyncMock(return_value=fake_conn)
    conn_cm.__aexit__ = AsyncMock(return_value=False)
    fake_pool.connection = MagicMock(return_value=conn_cm)

    # ---------- two independent cursor mocks ----------
    health_cursor = MagicMock()          # used by SELECT 1 health-check
    health_cursor.execute = AsyncMock()
    health_cursor.fetchall = AsyncMock()

    test_cursor = MagicMock()            # used by the query under test
    test_cursor.execute = AsyncMock()
    test_cursor.fetchall = AsyncMock()

    def _cursor_side_effect():
        """Return a fresh async-CM whose __aenter__ gives the right cursor."""
        cursor = health_cursor if not hasattr(_cursor_side_effect, "used") else test_cursor
        _cursor_side_effect.used = True
        cm = MagicMock()
        cm.__aenter__ = AsyncMock(return_value=cursor)
        cm.__aexit__ = AsyncMock(return_value=False)
        return cm

    fake_conn.cursor.side_effect = _cursor_side_effect

    return fake_pool, test_cursor
