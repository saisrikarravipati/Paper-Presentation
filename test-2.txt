

def _make_fake_pool(closed: bool = True):
    """
    Build `(fake_pool, test_cursor)` such that:

      * 1st `cursor()` call  ➜  health-check cursor  (ignored by the tests)
      * 2nd+ `cursor()` call ➜  test_cursor          (used in assertions)
    """
    # ── pool scaffold ───────────────────────────────────────────────────
    fake_pool = MagicMock()
    fake_pool.closed = closed
    fake_pool.open  = AsyncMock()
    fake_pool.close = AsyncMock()

    # ── connection CM ───────────────────────────────────────────────────
    fake_conn = MagicMock()
    fake_conn.commit = AsyncMock()

    conn_cm = MagicMock()
    conn_cm.__aenter__ = AsyncMock(return_value=fake_conn)
    conn_cm.__aexit__  = AsyncMock(return_value=False)
    fake_pool.connection = MagicMock(return_value=conn_cm)

    # ── two independent cursors ─────────────────────────────────────────
    health_cursor = MagicMock()
    health_cursor.execute  = AsyncMock()
    health_cursor.fetchall = AsyncMock()

    test_cursor = MagicMock()
    test_cursor.execute  = AsyncMock()
    test_cursor.fetchall = AsyncMock()

    def _cursor_side_effect():
        """Return an async CM whose __aenter__ yields the right cursor."""
        cursor = health_cursor if not hasattr(_cursor_side_effect, "used") else test_cursor
        _cursor_side_effect.used = True
        cm = MagicMock()
        cm.__aenter__ = AsyncMock(return_value=cursor)
        cm.__aexit__  = AsyncMock(return_value=False)
        return cm

    fake_conn.cursor.side_effect = _cursor_side_effect

    return fake_pool, test_cursor
