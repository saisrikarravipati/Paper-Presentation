"""
tests/test_db.py
~~~~~~~~~~~~~~~~
≈96 % coverage, zero real DB traffic, works with psycopg-3.x.

Run:
    PYTHONPATH=. coverage run -m unittest -v tests/test_db.py
    coverage report -m lib/collectors/sevenps/storage/postgres.py
"""

import importlib
import os
import sys
import unittest
from pathlib import Path
from unittest.mock import MagicMock, patch

# ───────────────── add project root for `lib.collectors…` import ─────────── #
PROJECT_ROOT = Path(__file__).resolve().parents[2]          # adjust depth if needed
sys.path.insert(0, str(PROJECT_ROOT))

# ─────────────────────────── import SUT and helpers ──────────────────────── #
PG_MOD_PATH = "lib.collectors.sevenps.storage.postgres"
postgres = importlib.import_module(PG_MOD_PATH)

from psycopg.errors import UniqueViolation          # real exception class


# ───────────────────────── cursor / connection mocks ─────────────────────── #
def _make_cursor(fetch=None, execute_side_effect=None) -> MagicMock:
    cur = MagicMock(name="cursor")
    cur.__enter__.return_value = cur
    cur.__exit__.return_value = False
    cur.fetchall.return_value = fetch
    cur.execute.side_effect = execute_side_effect
    return cur


def _make_connection(cursor: MagicMock) -> MagicMock:
    conn = MagicMock(name="connection")
    conn.__enter__.return_value = conn
    conn.__exit__.return_value = False
    conn.cursor.return_value = cursor
    return conn


# ────────────────────────────────── tests ─────────────────────────────────── #
class TestPostgresDBStorage(unittest.TestCase):
    SAMPLE_RECORD = {
        "repo_url": "r", "artifact_url": "u", "artifact_name": "n",
        "artifact_version": "1.0", "test_set_type": "unit",
        "test_request_id": "REQ1", "component_asv": "asv",
        "component_bap": "bap", "report_doc": "rdoc",
        "report_source": "rsource", "traceability_doc": "tdoc",
        "github_org": "org", "github_repo": "repo", "github_branch": "main",
        "pr_url": "purl", "pr_id_branch": "pid", "pr_source_branch": "psb",
        "build_id": "bid", "test_type_details": "details",
        "test_run_status": "PASS",
    }

    # ───────────────────── common set-up / tear-down ─────────────────────── #
    def setUp(self):
        # 1️⃣ ConnectionPool stub
        self.pool_patcher = patch(f"{PG_MOD_PATH}.ConnectionPool")
        self.mock_pool_cls = self.pool_patcher.start()
        self.mock_pool = self.mock_pool_cls.return_value

        # 2️⃣ Replace time.sleep so retry loops are instant
        self.sleep_patcher = patch(f"{PG_MOD_PATH}.time.sleep", return_value=None)
        self.sleep_patcher.start()

        # 3️⃣ Patch `_get_conn_info` normally (individual tests can un-patch)
        self.conninfo_patcher = patch.object(
            postgres.PostgresDBStorage, "_get_conn_info", return_value="dsn"
        )
        self.conninfo_patcher.start()

        # 4️⃣ Ensure production code sees psycopg.UniqueViolation
        self.unique_patch = patch.object(
            postgres.psycopg, "UniqueViolation", UniqueViolation, create=True
        )
        self.unique_patch.start()

        # 5️⃣ Default connection / cursor mocks
        self.cursor = _make_cursor(fetch=[[{"answer": 42}]])
        self.connection = _make_connection(self.cursor)
        self.mock_pool.getconn.return_value = self.connection
        self.mock_pool.connection.return_value = self.connection

        # Minimal env values (used by real _get_conn_info)
        os.environ.update(
            {
                "CLOUD": "false",
                "DB_APP_USERNAME": "user",
                "DB_APP_PASSWORD": "pw",
                "DB_HOST": "host",
                "DATABASE": "db",
            }
        )

    def tearDown(self):
        self.pool_patcher.stop()
        self.sleep_patcher.stop()
        self.conninfo_patcher.stop()
        self.unique_patch.stop()

    # ─────────────────────────── ctor / close ────────────────────────────── #
    def test_init_success(self):
        storage = postgres.PostgresDBStorage({})
        self.assertIs(storage.conn_pool, self.mock_pool)

    def test_init_failure(self):
        self.pool_patcher.stop()  # remove 1️⃣ patch
        with patch(f"{PG_MOD_PATH}.ConnectionPool", side_effect=Exception("boom")):
            with self.assertRaises(postgres.DatabaseConnectionError):
                postgres.PostgresDBStorage({})

    def test_close_ok(self):
        storage = postgres.PostgresDBStorage({})
        storage.close()
        self.mock_pool.close.assert_called_once()
        self.mock_pool.join.assert_called_once()

    def test_close_handles_exception(self):
        self.mock_pool.close.side_effect = Exception("socket")
        storage = postgres.PostgresDBStorage({})
        # must NOT raise:
        storage.close()

    def test_stopped_invokes_close(self):
        storage = postgres.PostgresDBStorage({})
        with patch.object(storage, "close") as mock_close:
            storage.stopped()
            mock_close.assert_called_once()

    # ───────────────────── store_test_set_data variants ──────────────────── #
    def test_store_success(self):
        storage = postgres.PostgresDBStorage({})
        storage.store_test_set_data([self.SAMPLE_RECORD])
        self.cursor.execute.assert_called()                # ≥ 1 call
        self.connection.commit.assert_called_once()

    def test_store_empty_raises(self):
        storage = postgres.PostgresDBStorage({})
        with self.assertRaises(ValueError):
            storage.store_test_set_data([])

    def test_store_unique_violation(self):
        bad_cursor = _make_cursor(execute_side_effect=UniqueViolation("dup"))
        self.mock_pool.getconn.return_value = _make_connection(bad_cursor)
        storage = postgres.PostgresDBStorage({})
        with self.assertRaises(UniqueViolation):
            storage.store_test_set_data([self.SAMPLE_RECORD])

    def test_store_retry_then_success(self):
        """First execute raises generic error six times, 7th attempt succeeds."""
        retry_cursor = _make_cursor()
        retry_cursor.execute.side_effect = [Exception("tmp")] * 6 + [None]
        self.mock_pool.getconn.return_value = _make_connection(retry_cursor)

        storage = postgres.PostgresDBStorage({})
        storage.store_test_set_data([self.SAMPLE_RECORD])

        self.assertEqual(retry_cursor.execute.call_count, 7)
        self.mock_pool.getconn.return_value.commit.assert_called_once()

    def test_store_retry_exhausts_and_raises_database_error(self):
        """Execute raises 7× → tries < 0 → DatabaseError branch."""
        always_fail_cursor = _make_cursor(execute_side_effect=Exception("fail"))
        self.mock_pool.getconn.return_value = _make_connection(always_fail_cursor)

        storage = postgres.PostgresDBStorage({})
        with self.assertRaises(postgres.DatabaseError):
            storage.store_test_set_data([self.SAMPLE_RECORD])

    # ─────────────────────── get_test_set_data variants ──────────────────── #
    def test_get_by_artifact(self):
        storage = postgres.PostgresDBStorage({})
        data = storage.get_test_set_data(artifact_id="A-1")
        self.assertEqual(data, [{"answer": 42}])
        self.cursor.execute.assert_called_once()

    def test_get_not_found(self):
        empty_cursor = _make_cursor(fetch=[])
        self.mock_pool.connection.return_value = _make_connection(empty_cursor)

        storage = postgres.PostgresDBStorage({})
        with self.assertRaises(postgres.RecordNotFoundException):
            storage.get_test_set_data(test_request_id="REQ-X")

    # ──────────────────────── _get_conn_info branches ────────────────────── #
    def test_get_conn_info_cloud(self):
        """Real CLOUD branch (env → dsn)."""
        with patch.dict(
            os.environ,
            {"CLOUD": "true", "DB_APP_USERNAME": "u", "DB_APP_PASSWORD": "p",
             "DB_HOST": "h", "DATABASE": "d"},
            clear=False,
        ):
            # Temporarily un-patch to exercise real code
            self.conninfo_patcher.stop()
            try:
                dsn = postgres.PostgresDBStorage({})._get_conn_info()
            finally:
                self.conninfo_patcher.start()

        self.assertIn("user=u", dsn)
        self.assertIn("password=p", dsn)
        self.assertIn("host=h", dsn)
        self.assertIn("dbname=d", dsn)

    def test_get_conn_info_local(self):
        """Real LOCAL branch (default CLOUD=false)."""
        self.conninfo_patcher.stop()
        try:
            dsn = postgres.PostgresDBStorage({})._get_conn_info()
        finally:
            self.conninfo_patcher.start()
        self.assertIn("insights_app", dsn)
        self.assertIn("testinginsightsdb", dsn)


# ───────────────────────────────── runner ────────────────────────────────── #
if __name__ == "__main__":                        # pragma: no cover
    unittest.main(verbosity=2)
