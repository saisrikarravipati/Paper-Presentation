package policy.enforcement.TMM.automated_test_validation

import data.policy.lib.data
import data.policy.lib.functions.match_test_names
import data.policy.lib.functions.sanitize_test_names
import rego.v1

# Precompute test case data safely
sevenps_entry := {test_case: tc_status |
    some i
    test_case := input.sevenps_test_cases[i].testCaseId
    tc_status := [status |
        some j
        input.sevenps_test_cases[j].testCaseId == test_case
        status := input.sevenps_test_cases[j].status
    ]
}

sanitized_sevenps_entry := {test_case: tc_status |
    some k
    original_test_case := input.sevenps_test_cases[k].testCaseId
    tc_status := sevenps_entry[original_test_case]
    test_case := sanitize_test_names(original_test_case)
}

# Jira ID processing
traceability_jira_ids contains jira_id if {
    some m
    traceability_item := input.traceability_data[m]
    jira_id := traceability_item.jira_id
}

valid_traceability_data contains item if {
    some n
    item := input.traceability_data[n]
    item.jira_id in input.jira_data
}

# Test case resolution
unique_jira_test_cases contains test_case if {
    some p, q
    entry := valid_traceability_data[p]
    test_case := entry.test_cases[q]
}

jira_test_case_statuses[test_case] := status if {
    some r
    test_case := unique_jira_test_cases[r]
    status := sevenps_entry[test_case]
}

jira_test_case_statuses[test_case] := tc_status if {
    some s
    test_case := unique_jira_test_cases[s]
    not sevenps_entry[test_case]
    sanitized_test := sanitize_test_names(test_case)
    some key
    sanitized_sevenps_entry[key]
    match_test_names(sanitized_test, key)
    tc_status := sanitized_sevenps_entry[key][_]
}

# Validation rules
in_array(arr, elem) := true if {
    some i
    arr[i] == elem
}

valid_status(status_list) := true if {
    some j
    status := status_list[j]
    in_array(data.valid_automated_test_case_status, status)
}

missing_jira_ids contains jira_id if {
    some k
    jira_id := input.jira_data[k]
    not in_array(traceability_jira_ids, jira_id)
}

missing_test_case_id contains test_id if {
    some l
    test_id := unique_jira_test_cases[l]
    not jira_test_case_statuses[test_id]
    count(test_id) > 8
}

missing_test_case_id contains test_case if {
    some m
    test_case := unique_jira_test_cases[m]
    not valid_status(jira_test_case_statuses[test_case])
    count(test_case) > 0
}

# Results generation (OPA 0.59.0 compatible)
results["missing_id_automated"] := missing_test_case_id if {
    count(missing_test_case_id) > 0
} else := set()

results["missing_jira_ids"] := missing_jira_ids if {
    count(missing_jira_ids) > 0
} else := set()

default decision = "FAIL"
decision = "PASS" if {
    count(missing_test_case_id) == 0
    count(missing_jira_ids) == 0
}

results["decision"] := decision
results["total_traceability_tests"] := count(unique_jira_test_cases)
results["valid_traceability_tests"] := count(unique_jira_test_cases) - count(missing_test_case_id)












################################################################


package policy.lib.functions
import rego.v1

# Regex patterns (precompiled)
end_pattern_1 := `:?--@\d+?\.\d+?.*`
end_pattern_2 := `#\d+?(\.?\d+)?`
end_pattern_3 := `\(example#\d\)`
start_pattern := `\[\d+?(?:\.\d+?)?:\d+\]`

is_empty_or_undefined(response) := true if {
    response == null
} else := true if {
    response == ""
} else := true if {
    response == {}
} else := true if {
    response == []
} else := false

match_test_names(test_case_name, test_result_name) := true if {
    sanitized_tc := sanitize_test_names(test_case_name)
    sanitized_tr := sanitize_test_names(test_result_name)
    match_sanitized_test_names(sanitized_tc, sanitized_tr)
}

match_sanitized_test_names(tc, tr) := true if {
    tc == tr
} else := true if {
    regex.template_match(tc + end_pattern_1, tr, "S", "F")
} else := true if {
    regex.template_match(tc + end_pattern_2 + "F", tr, "S", "F")
} else := true if {
    regex.template_match(tc + end_pattern_3, tr, "S", "F")
} else := true if {
    regex.template_match(start_pattern + tc, tr, "S", "F")
} else := false

sanitize_test_names(test_name) := sanitized_test_name if {
    step1 := lower(replace(test_name, " ", ""))
    step2 := replace(step1, "\\u203a", ">")
    step3 := replace(step2, "\\u003e", ">")
    step4 := replace(step3, "\\u003c", "<")
    sanitized_test_name := replace(step4, `\`, ``)
} else := test_name

fmt_number_to_string(n) := f if {
    f := sprintf("%.2f", [n])
    contains(f, ".")
} else := sprintf("%d", [n])
