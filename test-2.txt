"""
tests/test_db.py
────────────────
Covers every branch in lib.collectors.sevenps.storage.postgres without touching
a real database.  Logging is ignored via MagicMock.
"""
from __future__ import annotations

import importlib
import os
import unittest
from contextlib import contextmanager
from unittest.mock import MagicMock, patch

# ─────────── import the storage module once ─────────── #
postgres = importlib.import_module("lib.collectors.sevenps.storage.postgres")

# ─────────── neutralise logging (no assertions) ───────── #
postgres.logger = MagicMock()
postgres.cyber_logger = MagicMock()

# ─────────── lightweight fake psycopg-pool ───────────── #
class _FakeConn(MagicMock):
    def __init__(self):
        super().__init__(name="connection")
        cur = MagicMock(name="cursor")
        cur.__enter__.return_value = cur
        cur.__exit__.return_value = None
        self.cursor.return_value = cur
        self.commit = MagicMock()
        self.rollback = MagicMock()

class _FakePool:
    def __init__(self, conninfo: str, **_):
        self.conninfo = conninfo
        self.conn = _FakeConn()
        self.put_calls = 0
        self.closed = False

    # legacy API
    def getconn(self): return self.conn
    def putconn(self, _): self.put_calls += 1

    # context-manager API
    @contextmanager
    def connection(self):
        try:
            yield self.conn
        finally:
            self.putconn(self.conn)

    # graceful shutdown helpers
    def close(self): self.closed = True
    def join(self):  ...

# Guarantee `UniqueViolation` exists even if psycopg isn't installed
if not hasattr(postgres.psycopg, "UniqueViolation"):
    class _FakeUV(Exception): ...
    postgres.psycopg.UniqueViolation = _FakeUV


# ─────────────────────────── TESTS ─────────────────────────── #
class TestPostgresDBStorage(unittest.TestCase):
    def setUp(self):
        # Patch the pool class *inside* the already-imported module
        self.pool_patch = patch.object(postgres, "ConnectionPool", _FakePool)
        self.pool_patch.start()

        # Force local branch for _get_conn_info
        with patch.dict(os.environ, {"CLOUD": "false"}):
            self.storage = postgres.PostgresDBStorage({"min_connections": 1})

        self.pool = self.storage.conn_pool
        self.conn = self.pool.conn
        self.cur = self.conn.cursor.return_value

    def tearDown(self):
        self.pool_patch.stop()

    # ------------- store_test_set_data_async paths ------------- #
    @patch("time.sleep", return_value=None)
    def test_store_success(self, _):
        record = {k: "1" for k in (
            "repo_url", "artifact_url", "artifact_name", "artifact_version",
            "test_set_type", "test_request_id", "component_asv", "component_bap",
            "report_doc", "report_source", "traceability_doc",
            "github_org", "github_repo", "github_branch",
            "pr_url", "pr_id_branch", "pr_source_branch",
            "build_id", "test_type_details", "test_run_status")}
        self.storage.store_test_set_data_async([record])

        self.cur.execute.assert_called_once()
        self.conn.commit.assert_called_once()
        self.assertEqual(self.pool.put_calls, 1)

    @patch("time.sleep", return_value=None)
    def test_store_unique_violation(self, _):
        self.cur.execute.side_effect = postgres.psycopg.UniqueViolation("dup")
        with self.assertRaises(postgres.psycopg.UniqueViolation):
            self.storage.store_test_set_data_async([{"artifact_url": "dup"}])

        self.conn.rollback.assert_called_once()
        self.assertEqual(self.pool.put_calls, 1)

    @patch("time.sleep", return_value=None)
    def test_store_retry_then_database_error(self, _):
        self.cur.execute.side_effect = Exception("boom")
        with self.assertRaises(postgres.DatabaseError):
            self.storage.store_test_set_data_async([{"artifact_url": "x"}])

        self.assertEqual(self.conn.rollback.call_count, 7)  # 6→0
        self.assertEqual(self.pool.put_calls, 7)

    def test_store_empty_input(self):
        with self.assertRaises(ValueError):
            self.storage.store_test_set_data_async([])

    # ------------- get_test_set_data paths --------------------- #
    def test_get_data_found(self):
        self.cur.fetchall.return_value = [("json-value",)]
        self.assertEqual(
            self.storage.get_test_set_data(artifact_id="1"), ["json-value"])
        self.assertEqual(self.pool.put_calls, 1)

    def test_get_data_not_found(self):
        self.cur.fetchall.return_value = []
        with self.assertRaises(postgres.RecordNotFoundException):
            self.storage.get_test_set_data(test_request_id="none")
        self.assertEqual(self.pool.put_calls, 1)

    def test_get_data_bad_args(self):
        with self.assertRaises(ValueError):
            self.storage.get_test_set_data()

    # ------------- _get_conn_info cloud branch --------------- #
    def test_get_conn_info_cloud(self):
        env = {
            "CLOUD": "true", "DB_APP_USERNAME": "u", "DB_APP_PASSWORD": "p",
            "DB_HOST": "h", "DATABASE": "d"
        }
        with patch.dict(os.environ, env):
            info = postgres.PostgresDBStorage({"min_connections": 1})._get_conn_info()
        self.assertIn("host=h", info)

    # ------------- constructor failure branch ---------------- #
    def test_init_failure(self):
        with patch.object(postgres, "ConnectionPool", side_effect=Exception):
            with self.assertRaises(postgres.DatabaseConnectionError):
                postgres.PostgresDBStorage({})

    # ------------- graceful shutdown ------------------------- #
    def test_close_and_stopped(self):
        self.storage.close()
        self.assertTrue(self.pool.closed)
        self.storage.stopped()   # second call is harmless
