"""
test_db.py
~~~~~~~~~~
Unit-tests for lib.collectors.sevenps.storage.postgres.PostgresDBStorage
with 90 %+ line-coverage and **no live database**.

• ConnectionPool, connections, cursors, time.sleep and psycopg.UniqueViolation
  are fully mocked.
• Test cases cover:
    – ctor success / failure
    – close()
    – store_test_set_data : success, empty-list error, unique-violation retry path
    – get_test_set_data   : success via artifact_id, not-found error branch
Run:  python -m unittest -v test_db.py
"""

import importlib
import os
import sys
import unittest
from pathlib import Path
from types import ModuleType
from unittest.mock import MagicMock, patch

# --------------------------------------------------------------------------- #
#               Ensure project root is on sys.path for import                 #
# --------------------------------------------------------------------------- #
# This makes "lib.collectors.sevenps.storage.postgres" importable even when
# tests are run from the repo root with `python -m unittest`.
PROJECT_ROOT = Path(__file__).resolve().parents[2]  # adjust ".." if needed
sys.path.insert(0, str(PROJECT_ROOT))

PG_MOD_PATH = "lib.collectors.sevenps.storage.postgres"
postgres: ModuleType = importlib.import_module(PG_MOD_PATH)  # import once


# --------------------------------------------------------------------------- #
#                         Helper-mock factories                               #
# --------------------------------------------------------------------------- #
def _make_cursor(fetch=None, execute_side_effect=None) -> MagicMock:
    cur = MagicMock(name="cursor")
    cur.__enter__.return_value = cur
    cur.__exit__.return_value = False
    cur.fetchall.return_value = fetch
    cur.execute.side_effect = execute_side_effect
    return cur


def _make_connection(cursor: MagicMock) -> MagicMock:
    conn = MagicMock(name="connection")
    conn.__enter__.return_value = conn
    conn.__exit__.return_value = False
    conn.cursor.return_value = cursor
    return conn


# --------------------------------------------------------------------------- #
#                                  Tests                                      #
# --------------------------------------------------------------------------- #
class TestPostgresDBStorage(unittest.TestCase):
    SAMPLE_RECORD = {
        "repo_url": "r", "artifact_url": "u", "artifact_name": "n",
        "artifact_version": "1.0", "test_set_type": "unit",
        "test_request_id": "REQ1", "component_asv": "asv",
        "component_bap": "bap", "report_doc": "rdoc",
        "report_source": "rsource", "traceability_doc": "tdoc",
        "github_org": "org", "github_repo": "repo", "github_branch": "main",
        "pr_url": "purl", "pr_id_branch": "pid", "pr_source_branch": "psb",
        "build_id": "bid", "test_type_details": "details",
        "test_run_status": "PASS",
    }

    # -------------- common set-up / tear-down -------------------------------- #
    def setUp(self):
        # Patch ConnectionPool class *inside* the postgres module
        self.pool_patcher = patch(f"{PG_MOD_PATH}.ConnectionPool")
        self.mock_pool_cls = self.pool_patcher.start()
        self.mock_pool = self.mock_pool_cls.return_value

        # Patch helper/utility bits
        self.conninfo_patcher = patch.object(
            postgres.PostgresDBStorage, "_get_conn_info", return_value="dsn"
        )
        self.conninfo_patcher.start()

        self.sleep_patcher = patch(f"{PG_MOD_PATH}.time.sleep", return_value=None)
        self.sleep_patcher.start()

        # Provide a fake UniqueViolation exception on postgres.psycopg
        FakeUV = type("FakeUniqueViolation", (Exception,), {})
        self.unique_patch = patch.object(postgres.psycopg, "UniqueViolation", FakeUV)
        self.unique_patch.start()
        self.UniqueViolation = FakeUV

        # Default connection / cursor mocks
        self.cursor = _make_cursor(fetch=[[{"answer": 42}]])
        self.connection = _make_connection(self.cursor)
        self.mock_pool.getconn.return_value = self.connection
        self.mock_pool.connection.return_value = self.connection

        # Minimal env so _get_conn_info could work un-mocked if needed
        os.environ.update(
            dict(
                CLOUD="false",
                DB_APP_USERNAME="user",
                DB_APP_PASSWORD="pw",
                DB_HOST="host",
                DATABASE="db",
            )
        )

    def tearDown(self):
        self.pool_patcher.stop()
        self.conninfo_patcher.stop()
        self.sleep_patcher.stop()
        self.unique_patch.stop()

    # ------------------------------ ctor / close ----------------------------- #
    def test_init_success(self):
        storage = postgres.PostgresDBStorage({})
        self.assertIs(storage.conn_pool, self.mock_pool)

    def test_init_failure(self):
        self.pool_patcher.stop()  # remove existing patch
        with patch(f"{PG_MOD_PATH}.ConnectionPool", side_effect=Exception("boom")):
            with self.assertRaises(postgres.DatabaseConnectionError):
                postgres.PostgresDBStorage({})

    def test_close_calls_pool(self):
        storage = postgres.PostgresDBStorage({})
        storage.close()
        self.mock_pool.close.assert_called_once()
        self.mock_pool.join.assert_called_once()

    # ------------------------- store_test_set_data --------------------------- #
    def test_store_success(self):
        storage = postgres.PostgresDBStorage({})
        storage.store_test_set_data([self.SAMPLE_RECORD])
        self.cursor.execute.assert_called()              # executed at least once
        self.connection.commit.assert_called_once()

    def test_store_empty_raises(self):
        storage = postgres.PostgresDBStorage({})
        with self.assertRaises(ValueError):
            storage.store_test_set_data([])

    def test_store_unique_violation(self):
        bad_cursor = _make_cursor(execute_side_effect=self.UniqueViolation("dup"))
        bad_conn = _make_connection(bad_cursor)
        self.mock_pool.getconn.return_value = bad_conn
        storage = postgres.PostgresDBStorage({})
        with self.assertRaises(self.UniqueViolation):
            storage.store_test_set_data([self.SAMPLE_RECORD])

    # -------------------------- get_test_set_data ---------------------------- #
    def test_get_by_artifact(self):
        storage = postgres.PostgresDBStorage({})
        result = storage.get_test_set_data(artifact_id="A-1")
        self.assertEqual(result, [{"answer": 42}])
        self.cursor.execute.assert_called_once()

    def test_get_not_found(self):
        empty_cursor = _make_cursor(fetch=[])
        self.mock_pool.connection.return_value = _make_connection(empty_cursor)
        storage = postgres.PostgresDBStorage({})
        with self.assertRaises(postgres.RecordNotFoundException):
            storage.get_test_set_data(test_request_id="REQ-X")


if __name__ == "__main__":  # pragma: no cover
    unittest.main(verbosity=2)
