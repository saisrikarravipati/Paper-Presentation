# test_db.py
import importlib
import os
import unittest
from unittest.mock import patch, MagicMock

# Import the module under test once, so all patches hit the same object.
postgres = importlib.import_module("postgres")


# --------------------------------------------------------------------------- #
#                           Helper factories                                  #
# --------------------------------------------------------------------------- #
def _make_cursor(fetch=None, execute_side_effect=None):
    """Return a MagicMock that behaves like a DB cursor."""
    cur = MagicMock(name="cursor")
    cur.__enter__.return_value = cur
    cur.__exit__.return_value = False
    cur.fetchall.return_value = fetch
    cur.execute.side_effect = execute_side_effect
    return cur


def _make_connection(cursor):
    """Return a MagicMock that behaves like a DB connection."""
    conn = MagicMock(name="connection")
    conn.__enter__.return_value = conn
    conn.__exit__.return_value = False
    conn.cursor.return_value = cursor
    return conn


# --------------------------------------------------------------------------- #
#                               The tests                                     #
# --------------------------------------------------------------------------- #
class TestPostgresDBStorage(unittest.TestCase):
    """Unit-tests for postgres.PostgresDBStorage with heavy mocking."""

    SAMPLE_RECORD = {
        "repo_url": "r",
        "artifact_url": "u",
        "artifact_name": "n",
        "artifact_version": "1.0",
        "test_set_type": "unit",
        "test_request_id": "REQ1",
        "component_asv": "asv",
        "component_bap": "bap",
        "report_doc": "rdoc",
        "report_source": "rsource",
        "traceability_doc": "tdoc",
        "github_org": "org",
        "github_repo": "repo",
        "github_branch": "main",
        "pr_url": "purl",
        "pr_id_branch": "pid",
        "pr_source_branch": "psb",
        "build_id": "bid",
        "test_type_details": "details",
        "test_run_status": "PASS",
    }

    def setUp(self):
        # ---- Patch ConnectionPool -------------------------------------------------
        self.pool_patcher = patch("postgres.ConnectionPool")
        self.mock_pool_cls = self.pool_patcher.start()
        self.mock_pool = self.mock_pool_cls.return_value

        # ---- Patch _get_conn_info so no env vars are required ---------------------
        self.conninfo_patcher = patch.object(
            postgres.PostgresDBStorage, "_get_conn_info", return_value="dummy-dsn"
        )
        self.conninfo_patcher.start()

        # ---- Patch time.sleep so the retry loop is instant ------------------------
        self.sleep_patcher = patch("postgres.time.sleep", return_value=None)
        self.sleep_patcher.start()

        # ---- Provide a fake psycopg.UniqueViolation ------------------------------
        FakeUnique = type("FakeUniqueViolation", (Exception,), {})
        self.unique_patch = patch.object(postgres.psycopg, "UniqueViolation", FakeUnique)
        self.unique_patch.start()
        self.UniqueViolation = FakeUnique

        # ---- Provide default connection / cursor mocks ---------------------------
        self.cursor = _make_cursor(fetch=[[{"answer": 42}]])
        self.connection = _make_connection(self.cursor)
        self.mock_pool.getconn.return_value = self.connection
        self.mock_pool.connection.return_value = self.connection

        # Environment so _get_conn_info could succeed if used elsewhere.
        os.environ.update(
            {
                "CLOUD": "false",
                "DB_APP_USERNAME": "u",
                "DB_APP_PASSWORD": "p",
                "DB_HOST": "h",
                "DATABASE": "d",
            }
        )

    def tearDown(self):
        self.pool_patcher.stop()
        self.conninfo_patcher.stop()
        self.sleep_patcher.stop()
        self.unique_patch.stop()

    # ----------------------------------------------------------------------- #
    #                          ctor / close                                   #
    # ----------------------------------------------------------------------- #
    def test_init_success(self):
        storage = postgres.PostgresDBStorage({})
        self.assertIs(storage.conn_pool, self.mock_pool)

    def test_init_failure(self):
        self.pool_patcher.stop()  # un-patch, then re-patch with side-effect
        with patch("postgres.ConnectionPool", side_effect=Exception("boom")):
            with self.assertRaises(postgres.DatabaseConnectionError):
                postgres.PostgresDBStorage({})

    def test_close_calls_pool_methods(self):
        storage = postgres.PostgresDBStorage({})
        storage.close()
        self.mock_pool.close.assert_called_once()
        self.mock_pool.join.assert_called_once()

    # ----------------------------------------------------------------------- #
    #                    store_test_set_data                                  #
    # ----------------------------------------------------------------------- #
    def test_store_success(self):
        storage = postgres.PostgresDBStorage({})
        storage.store_test_set_data([self.SAMPLE_RECORD])
        self.cursor.execute.assert_called()          # at least once
        self.connection.commit.assert_called_once()

    def test_store_empty_list_raises(self):
        storage = postgres.PostgresDBStorage({})
        with self.assertRaises(ValueError):
            storage.store_test_set_data([])

    def test_store_unique_violation(self):
        bad_cursor = _make_cursor(
            execute_side_effect=self.UniqueViolation("duplicate key")
        )
        bad_conn = _make_connection(bad_cursor)
        self.mock_pool.getconn.return_value = bad_conn
        storage = postgres.PostgresDBStorage({})
        with self.assertRaises(self.UniqueViolation):
            storage.store_test_set_data([self.SAMPLE_RECORD])

    # ----------------------------------------------------------------------- #
    #                      get_test_set_data                                  #
    # ----------------------------------------------------------------------- #
    def test_get_by_artifact_id(self):
        storage = postgres.PostgresDBStorage({})
        result = storage.get_test_set_data(artifact_id="A123")
        self.assertEqual(result, [{"answer": 42}])
        self.cursor.execute.assert_called_once()

    def test_get_not_found(self):
        # empty fetchall triggers RecordNotFoundException
        empty_cursor = _make_cursor(fetch=[])
        self.mock_pool.connection.return_value = _make_connection(empty_cursor)
        storage = postgres.PostgresDBStorage({})
        with self.assertRaises(postgres.RecordNotFoundException):
            storage.get_test_set_data(test_request_id="REQ-X")


if __name__ == "__main__":  # pragma: no cover
    unittest.main(verbosity=2)
