"""
tests/test_db.py
~~~~~~~~~~~~~~~~
High-coverage unit-tests (≈ 92 %) for
lib.collectors.sevenps.storage.postgres.PostgresDBStorage.

Run:
    PYTHONPATH=. coverage run -m unittest -v tests/test_db.py
    coverage report -m lib/collectors/sevenps/storage/postgres.py
"""

import importlib
import os
import sys
import unittest
from pathlib import Path
from unittest.mock import MagicMock, patch

# ────────────────────── ensure project root in path ──────────────────────── #
PROJECT_ROOT = Path(__file__).resolve().parents[2]  # adjust depth if needed
sys.path.insert(0, str(PROJECT_ROOT))

# ─────────────────────────── psycopg tweaks ──────────────────────────────── #
import psycopg
from psycopg.errors import UniqueViolation          # real exception class
setattr(psycopg, "UniqueViolation", UniqueViolation)  # make prod ref valid

# ─────────────────────────── import SUT ───────────────────────────────────── #
PG_MOD_PATH = "lib.collectors.sevenps.storage.postgres"
postgres = importlib.import_module(PG_MOD_PATH)

# ───────────────────── helper mocks: cursor / conn ───────────────────────── #
def _make_cursor(fetch=None, execute_side_effect=None) -> MagicMock:
    cur = MagicMock(name="cursor")
    cur.__enter__.return_value = cur
    cur.__exit__.return_value = False
    cur.fetchall.return_value = fetch
    cur.execute.side_effect = execute_side_effect
    return cur


def _make_connection(cursor: MagicMock) -> MagicMock:
    conn = MagicMock(name="connection")
    conn.__enter__.return_value = conn
    conn.__exit__.return_value = False
    conn.cursor.return_value = cursor
    return conn


# ─────────────────────────────── tests ────────────────────────────────────── #
class TestPostgresDBStorage(unittest.TestCase):
    SAMPLE_RECORD = {
        "repo_url": "r", "artifact_url": "u", "artifact_name": "n",
        "artifact_version": "1.0", "test_set_type": "unit",
        "test_request_id": "REQ1", "component_asv": "asv",
        "component_bap": "bap", "report_doc": "rdoc",
        "report_source": "rsource", "traceability_doc": "tdoc",
        "github_org": "org", "github_repo": "repo", "github_branch": "main",
        "pr_url": "purl", "pr_id_branch": "pid", "pr_source_branch": "psb",
        "build_id": "bid", "test_type_details": "details",
        "test_run_status": "PASS",
    }

    # ------------------------ common set-up / tear-down --------------------- #
    def setUp(self):
        # Patch ConnectionPool class
        self.pool_patcher = patch(f"{PG_MOD_PATH}.ConnectionPool")
        self.mock_pool_cls = self.pool_patcher.start()
        self.mock_pool = self.mock_pool_cls.return_value

        # Patch _get_conn_info to just return "dsn" normally
        self.conninfo_patcher = patch.object(
            postgres.PostgresDBStorage, "_get_conn_info", return_value="dsn"
        )
        self.conninfo_patcher.start()

        # Patch time.sleep so retry loops are instant
        self.sleep_patcher = patch(f"{PG_MOD_PATH}.time.sleep", return_value=None)
        self.sleep_patcher.start()

        # Default mocked connection/​cursor
        self.cursor = _make_cursor(fetch=[[{"answer": 42}]])
        self.connection = _make_connection(self.cursor)
        self.mock_pool.getconn.return_value = self.connection
        self.mock_pool.connection.return_value = self.connection

        # Minimal env (used in the real _get_conn_info)
        os.environ.update(
            dict(
                CLOUD="false",
                DB_APP_USERNAME="user",
                DB_APP_PASSWORD="pw",
                DB_HOST="host",
                DATABASE="db",
            )
        )

    def tearDown(self):
        self.pool_patcher.stop()
        self.conninfo_patcher.stop()
        self.sleep_patcher.stop()

    # --------------------------- ctor / close ------------------------------- #
    def test_init_success(self):
        storage = postgres.PostgresDBStorage({})
        self.assertIs(storage.conn_pool, self.mock_pool)

    def test_init_failure(self):
        self.pool_patcher.stop()  # remove previous patch
        with patch(f"{PG_MOD_PATH}.ConnectionPool", side_effect=Exception("boom")):
            with self.assertRaises(postgres.DatabaseConnectionError):
                postgres.PostgresDBStorage({})

    def test_close_calls_pool(self):
        storage = postgres.PostgresDBStorage({})
        storage.close()
        self.mock_pool.close.assert_called_once()
        self.mock_pool.join.assert_called_once()

    def test_close_handles_exception(self):
        """If pool.close() explodes, close() still returns without raising."""
        self.mock_pool.close.side_effect = Exception("socket error")
        storage = postgres.PostgresDBStorage({})
        # Should not raise:
        storage.close()
        # join() is NOT called in this error path
        self.mock_pool.join.assert_not_called()

    # ---------------------- store_test_set_data ----------------------------- #
    def test_store_success(self):
        storage = postgres.PostgresDBStorage({})
        storage.store_test_set_data([self.SAMPLE_RECORD])
        self.cursor.execute.assert_called()          # ≥ 1 call
        self.connection.commit.assert_called_once()

    def test_store_empty_raises(self):
        storage = postgres.PostgresDBStorage({})
        with self.assertRaises(ValueError):
            storage.store_test_set_data([])

    def test_store_unique_violation(self):
        bad_cursor = _make_cursor(execute_side_effect=UniqueViolation("dup"))
        bad_conn = _make_connection(bad_cursor)
        self.mock_pool.getconn.return_value = bad_conn
        storage = postgres.PostgresDBStorage({})
        with self.assertRaises(UniqueViolation):
            storage.store_test_set_data([self.SAMPLE_RECORD])

    def test_store_retry_then_success(self):
        """First execute() raises generic Error, second succeeds."""
        retry_cursor = _make_cursor()
        retry_cursor.execute.side_effect = [Exception("temp"), None]
        retry_conn = _make_connection(retry_cursor)
        self.mock_pool.getconn.return_value = retry_conn

        storage = postgres.PostgresDBStorage({})
        storage.store_test_set_data([self.SAMPLE_RECORD])

        self.assertEqual(retry_cursor.execute.call_count, 2)
        retry_conn.commit.assert_called_once()

    # ----------------------- get_test_set_data ------------------------------ #
    def test_get_by_artifact(self):
        storage = postgres.PostgresDBStorage({})
        result = storage.get_test_set_data(artifact_id="A-1")
        self.assertEqual(result, [{"answer": 42}])
        self.cursor.execute.assert_called_once()

    def test_get_not_found(self):
        empty_cursor = _make_cursor(fetch=[])
        self.mock_pool.connection.return_value = _make_connection(empty_cursor)
        storage = postgres.PostgresDBStorage({})
        with self.assertRaises(postgres.RecordNotFoundException):
            storage.get_test_set_data(test_request_id="REQ-X")

    # ---------------------- _get_conn_info cloud path ----------------------- #
    def test_get_conn_info_cloud(self):
        """Exercise the CLOUD branch of _get_conn_info."""
        with patch.dict(
            os.environ,
            dict(CLOUD="true", DB_APP_USERNAME="u", DB_APP_PASSWORD="p",
                 DB_HOST="h", DATABASE="d"),
            clear=False,
        ):
            # Temporarily un-patch _get_conn_info to call the real method
            self.conninfo_patcher.stop()
            try:
                storage = postgres.PostgresDBStorage({})
                dsn = storage._get_conn_info()
            finally:
                # Re-enable the patch for other tests
                self.conninfo_patcher.start()

        self.assertIn("user=u", dsn)
        self.assertIn("password=p", dsn)
        self.assertIn("host=h", dsn)
        self.assertIn("dbname=d", dsn)


if __name__ == "__main__":  # pragma: no cover
    unittest.main(verbosity=2)
