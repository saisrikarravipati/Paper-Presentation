package policy.lib.functions

import rego.v1
# If you need older-style regex usage, ensure you import it appropriately:
# import "regex"

################################################################################
# is_empty_or_undefined(response)
#
# Purpose:
#   Returns true if the given `response` is undefined, null-like, or empty.
#
# Sample Inputs / Outputs:
#   1) response = undefined  => true
#   2) response = ""         => true
#   3) response = {}         => true
#   4) response = []         => true
#   5) response = "hello"    => false
################################################################################
is_empty_or_undefined(response) {
  # 1) Check if `response` is not defined (i.e., no value provided)
  not response
} else {
  # 2) Check if `response` is an empty string
  response == ""
} else {
  # 3) Check if `response` is an empty object
  response == {}
} else {
  # 4) Check if `response` is an empty array
  response == []
}

################################################################################
# match_test_names(test_case_name, test_result_name)
#
# Purpose:
#   Given two test names, sanitize both, then check if they match by
#   a series of pattern rules defined in `match_sanitized_test_names`.
#
# Sample Inputs / Outputs:
#   1) test_case_name = "MyTestCase 1", test_result_name = "mytestcase1"
#      => true  (after sanitization, they match exactly)
#   2) test_case_name = "Test <X>", test_result_name = "testSomeValueXsomething"
#      => could be true if the bracket-based rules match
#
# Note:
#   - Returns false if none of the matching criteria are satisfied.
################################################################################
match_test_names(test_case_name, test_result_name) {
  sanitized_test_case_name := sanitize_test_names(test_case_name)
  sanitized_test_result_name := sanitize_test_names(test_result_name)
  match_sanitized_test_names(sanitized_test_case_name, sanitized_test_result_name)
} else = false

################################################################################
# match_sanitized_test_names(sanitized_test_case_name, sanitized_test_result_name)
#
# Purpose:
#   Once test names are sanitized and lowercased with special characters removed,
#   test if the result name "matches" the case name by any of several patterns:
#
#   1) Exact equality
#   2) Regex patterns that look for appended numbers or version strings
#   3) Patterns using angle brackets < ... >
#   4) Patterns using curly braces { ... }
#
#   This function returns true if any one of these conditions matches.
#
# Sample Inputs / Outputs:
#   1) sanitized_test_case_name = "testcasev10"
#      sanitized_test_result_name = "testcasev10" 
#      => true (exact match)
#
#   2) sanitized_test_case_name = "testcasev10"
#      sanitized_test_result_name = "testcasev10-@12.34.5something"
#      => true (regex template match for appended version info)
#
#   3) sanitized_test_case_name = "myexample<xyz>"
#      sanitized_test_result_name = "myexampleSOMETHINGxyzSOMETHING"
#      => true (all substrings from the angle-bracket split are contained)
#
#   4) sanitized_test_case_name = "myexample{abc}"
#      sanitized_test_result_name = "someprefixmyexampleabc"
#      => true (all substrings from the curly-brace split are contained)
#
#   5) None of the conditions met => false
################################################################################
match_sanitized_test_names(sanitized_test_case_name, sanitized_test_result_name) {
  # 1) Exact equality check
  sanitized_test_case_name == sanitized_test_result_name
} else {
  # 2) Pattern check: e.g., "testCaseSomething7-@[0-9]+7.[0-9]+7.*"
  #    S and F are the delimiters for the template match.
  end_pattern := `7-@[0-9]+7.[0-9]+7.*`
  pattern := sprintf("%s%s", [sanitized_test_case_name, end_pattern])
  regex.template_match(pattern, sanitized_test_result_name, "S", "F")
} else {
  # 3) Pattern check: "testCaseSomething#[0-9]+?"
  end_pattern := `#[0-9]+?`
  pattern := sprintf("%s%sF", [sanitized_test_case_name, end_pattern])
  regex.template_match(pattern, sanitized_test_result_name, "S", "F")
} else {
  # 4) Pattern check: "testCaseSomething\(example#[0-9]\)"
  end_pattern := `\(example#[0-9]\)`
  pattern := sprintf("%s%s", [sanitized_test_case_name, end_pattern])
  regex.template_match(pattern, sanitized_test_result_name, "S", "F")
} else {
  # 5) Pattern check: e.g., "[[0-9]+7(7:[0-9]+7)7:[0-9]+]testCaseSomething"
  start_pattern := `[[0-9]+7(7:[0-9]+7)7:[0-9]+]`
  pattern := sprintf("%s%s", [start_pattern, sanitized_test_case_name])
  regex.template_match(pattern, sanitized_test_result_name, "S", "F")
} else {
  # 6) Angle bracket check: if test_case_name contains `<` and `>`,
  #    split on `<(.*?)>` and ensure all substrings appear in the test_result_name.
  contains(sanitized_test_case_name, "<")
  contains(sanitized_test_case_name, ">")
  substrs := regex.split(`<(.*?)>`, sanitized_test_case_name)
  count({
    ss | 
    substrs[ss]
    contains(sanitized_test_result_name, substrs[ss])
  }) == count(substrs)
} else {
  # 7) Curly brace check: if test_case_name contains `{` and `}`,
  #    split on `\{(.*?)\}` and ensure all substrings appear in the test_result_name.
  contains(sanitized_test_case_name, "{")
  contains(sanitized_test_case_name, "}")
  # Adjust the split pattern to match curly braces. If your data has nested braces,
  # you may need more complex logic. This simple pattern is for demonstration.
  substrs := regex.split(`\{(.*?)\}`, sanitized_test_case_name)
  count({
    ss |
    substrs[ss]
    contains(sanitized_test_result_name, substrs[ss])
  }) == count(substrs)
} else = false

################################################################################
# sanitize_test_names(test_name)
#
# Purpose:
#   1) Lowercase the given test name and remove spaces.
#   2) Replace certain unicode literal escape sequences \u203a, \u003e, \u003c
#      with their ASCII equivalents for '>' and '<'.
#   3) Remove any remaining backslashes '\'.
#   If no transformations match, returns the original test_name.
#
# Sample Inputs / Outputs:
#   1) test_name = "   My Test  \u003E " => "mytest>"
#   2) test_name = "  EXAMPLE \u203a  Something" => "example>something"
################################################################################
sanitize_test_names(test_name) = sanitized_test_name {
  lowered_no_spaces_name := lower(replace(test_name, " ", ""))

  # Replace known unicode patterns for > and <:
  step1 := replace(lowered_no_spaces_name, "\\u203a", ">")
  step2 := replace(step1, "\\u003e", ">")
  step3 := replace(step2, "\\u003c", "<")

  # Remove remaining backslashes:
  sanitized_test_name := replace(step3, `\`, ``)
} else = test_name

################################################################################
# fmt_number_to_string(n)
#
# Purpose:
#   Converts a number (int or float) to a string. If it's a float, ensure
#   a decimal point is present. Otherwise, if it's an integer, keep it
#   integer-like. If not recognized as number, returns `n` as-is.
#
# Sample Inputs / Outputs:
#   1) n = 3 => "3"
#   2) n = 3.0 => "3.00"   (based on "%.2f" formatting)
#   3) n = 3.1415 => "3.14"
#   4) n = "NaNValue" => "NaNValue"
#
# Note:
#   Adjust your string formatting (e.g., "%.2f") as needed for your use-case.
################################################################################
fmt_number_to_string(n) = f {
  # Convert float to string with 2 decimal places
  f := sprintf("%.2f", [n])
  contains(f, ".")
} else = f {
  # Convert integer to string (which doesn't contain a decimal point)
  not contains(sprintf("%.2f", [n]), ".")
  f := sprintf("%v", [n])
} else = n

