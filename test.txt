package policy.enforcement.TMM.automated_test_validation

import data.policy.lib.data
import data.policy.lib.functions
import rego.v1

# Precompute Jira IDs set for O(1) lookups
jira_data_set := {jira_id | jira_id := input.jira_data[_]}

# Build test case status map with O(n) complexity
sevenps_entry := {testCaseId: statuses |
    testCaseId := input.sevenps_test_cases[_].testCaseId
    statuses := [tc.status | tc := input.sevenps_test_cases[_]; tc.testCaseId == testCaseId]
}

# Set of Jira IDs from traceability data
traceability_jira_ids := {jira_id |
    traceability_item := input.traceability_data[_]
    jira_id := traceability_item.jira_id
}

# Filter valid traceability items using set membership
valid_traceability_data contains item if {
    item := input.traceability_data[_]
    item.jira_id in jira_data_set
}

# Flatten all test cases from valid traceability items
unique_jira_test_cases := {tc |
    item := valid_traceability_data[_]
    tc := item.test_cases[_]
}

# Precompute sanitized keys for regex matching
precomputed_sanitized_sevenps_keys := {key: functions.sanitize_test_names(key) | key := sevenps_entry[_]}

# Rule for exact matches
jira_test_case_statuses[test_case] := status if {
    test_case := unique_jira_test_cases[_]
    status := sevenps_entry[test_case][_]
}

# Rule for regex matches (only when no exact match)
jira_test_case_statuses[test_case_regex] := status if {
    test_case_regex := unique_jira_test_cases[_]
    not sevenps_entry[test_case_regex]
    sanitized_test_case := functions.sanitize_test_names(test_case_regex)
    status := [s |
        some key in sevenps_entry
        sanitized_key := precomputed_sanitized_sevenps_keys[key]
        functions.match_sanitized_test_names(sanitized_test_case, sanitized_key)
        s := sevenps_entry[key][_]
    ]
}

# Valid status check using set
valid_automated_test_case_status_set := {status | status := data.valid_automated_test_case_status[_]}
valid_status(status_list) if {
    some status in status_list
    status in valid_automated_test_case_status_set
}

# Missing Jira IDs calculation
missing_jira_ids contains jira_id if {
    jira_id := input.jira_data[_]
    not jira_id in traceability_jira_ids
}

# Missing test case rules
missing_test_case_id contains test_id if {
    test_id := unique_jira_test_cases[_]
    not jira_test_case_statuses[test_id]
    count(test_id) > 8
}

missing_test_case_id contains test_case if {
    test_case := unique_jira_test_cases[_]
    not valid_status(jira_test_case_statuses[test_case])
}

# Final results with optimized calculations
results := {
    "missing_id_automated": missing_test_case_id if count(missing_test_case_id) > 0 else "",
    "missing_jira_ids": missing_jira_ids if count(missing_jira_ids) > 0 else [],
    "decision": "PASS" if count(missing_test_case_id) == 0 && count(missing_jira_ids) == 0 else "FAIL",
    "total_traceability_tests": count(unique_jira_test_cases),
    "valid_traceability_tests": count(unique_jira_test_cases) - count(missing_test_case_id)
}
















#########################################


package policy.lib.functions
import rego.v1

is_empty_or_undefined(response) if {
    not response
} else if {
    response == ""
} else if {
    response == {}
} else if {
    response == []
}

match_test_names(test_case_name, test_result_name) if {
    sanitized_case := sanitize_test_names(test_case_name)
    sanitized_result := sanitize_test_names(test_result_name)
    match_sanitized_test_names(sanitized_case, sanitized_result)
} else := false

match_sanitized_test_names(sanitized_case, sanitized_result) if {
    sanitized_case == sanitized_result
} else if {
    regex.template_match(sprintf("%sS7-@[0-9]+7.[0-9]+7.*F", [sanitized_case]), sanitized_result)
} else if {
    regex.template_match(sprintf("%sS#[0-9]+?F", [sanitized_case]), sanitized_result)
} else if {
    regex.template_match(sprintf("%sS(example#[0-9])F", [sanitized_case]), sanitized_result)
} else if {
    regex.template_match(sprintf("S[[0-9]+7(7:[0-9]+7)7:[0-9]+]%sF", [sanitized_case]), sanitized_result)
} else if {
    contains(sanitized_case, "<")
    contains(sanitized_case, ">")
    substrings := regex.split(`<(.*?)>`, sanitized_case)
    count({s | s := substrings[_]; contains(sanitized_result, s)}) == count(substrings)
} else if {
    contains(sanitized_case, "{")
    contains(sanitized_case, "}")
    substrings := regex.split(`{(.*?)}`, sanitized_case)
    count({s | s := substrings[_]; contains(sanitized_result, s)}) == count(substrings)
} else := false

sanitize_test_names(test_name) := sanitized_test_name if {
    # Combined replacements for better performance
    sanitized := regex.replace(
        regex.replace(
            regex.replace(
                lower(replace(test_name, " ", "")),
                `\\u(203a|003e|003c)`, {"\\u203a": ">", "\\u003e": ">", "\\u003c": "<"}
            ),
            `\\`, ""
        ),
        `\`, ""
    )
    sanitized_test_name := sanitized
} else := test_name

fmt_number_to_string(n) := f if {
    f := sprintf("%.2f", [n])
    contains(f, ".")
} else := f if {
    f := sprintf("%d", [n])
} else := n
