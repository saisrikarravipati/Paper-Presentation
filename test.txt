package policy.lib.functions

import rego.v1
# or import "regex" depending on your OPA version:
# import "regex"

###############################################################################
# is_empty_or_undefined(response)
#
# Returns `true` if `response` is effectively "empty" or undefined.
###############################################################################
is_empty_or_undefined(response) {
    # Body #1: Check if not defined or "null" in typical usage
    not response
} or {
    # Body #2: Empty string
    response == ""
} or {
    # Body #3: Empty object
    response == {}
} or {
    # Body #4: Empty array
    response == []
}

###############################################################################
# match_test_names(test_case_name, test_result_name)
#
# Sanitizes both names, then returns true if they match by any pattern
# in `match_sanitized_test_names(...)`.
###############################################################################
match_test_names(test_case_name, test_result_name) {
    sanitized_test_case_name := sanitize_test_names(test_case_name)
    sanitized_test_result_name := sanitize_test_names(test_result_name)
    match_sanitized_test_names(sanitized_test_case_name, sanitized_test_result_name)
}

###############################################################################
# match_sanitized_test_names(sanitized_test_case_name, sanitized_test_result_name)
#
# Returns `true` if the two sanitized strings match by any rule below.
###############################################################################
match_sanitized_test_names(sanitized_test_case_name, sanitized_test_result_name) {
    # 1) Exact match
    sanitized_test_case_name == sanitized_test_result_name
} or {
    # 2) Pattern check: appended version-like info
    end_pattern := `7-@[0-9]+7.[0-9]+7.*`
    pattern := sprintf("%s%s", [sanitized_test_case_name, end_pattern])
    regex.template_match(pattern, sanitized_test_result_name, "S", "F")
} or {
    # 3) Pattern check: `#[0-9]+?`
    end_pattern := `#[0-9]+?`
    pattern := sprintf("%s%sF", [sanitized_test_case_name, end_pattern])
    regex.template_match(pattern, sanitized_test_result_name, "S", "F")
} or {
    # 4) Pattern check: `\(example#[0-9]\)`
    end_pattern := `\(example#[0-9]\)`
    pattern := sprintf("%s%s", [sanitized_test_case_name, end_pattern])
    regex.template_match(pattern, sanitized_test_result_name, "S", "F")
} or {
    # 5) Pattern check: prefix `[[0-9]+7(7:[0-9]+7)7:[0-9]+]`
    start_pattern := `[[0-9]+7(7:[0-9]+7)7:[0-9]+]`
    pattern := sprintf("%s%s", [start_pattern, sanitized_test_case_name])
    regex.template_match(pattern, sanitized_test_result_name, "S", "F")
} or {
    # 6) Angle-bracket check: <...>
    contains(sanitized_test_case_name, "<")
    contains(sanitized_test_case_name, ">")
    substrs := regex.split(`<(.*?)>`, sanitized_test_case_name)
    count({
        ss |
        substrs[ss]
        contains(sanitized_test_result_name, substrs[ss])
    }) == count(substrs)
} or {
    # 7) Curly-brace check: {...}
    contains(sanitized_test_case_name, "{")
    contains(sanitized_test_case_name, "}")
    substrs := regex.split(`\{(.*?)\}`, sanitized_test_case_name)
    count({
        ss |
        substrs[ss]
        contains(sanitized_test_result_name, substrs[ss])
    }) == count(substrs)
}

###############################################################################
# sanitize_test_names(test_name) = ...
#
# Returns a sanitized string by:
# 1) Lowercasing and removing spaces
# 2) Replacing unicode escapes (\u203a, \u003e, \u003c) with '>' or '<'
# 3) Removing any remaining backslashes '\'
###############################################################################

default sanitize_test_names(test_name) = test_name

sanitize_test_names(test_name) = sanitized_test_name {
    lowered_no_spaces_name := lower(replace(test_name, " ", ""))

    step1 := replace(lowered_no_spaces_name, "\\u203a", ">")
    step2 := replace(step1, "\\u003e", ">")
    step3 := replace(step2, "\\u003c", "<")

    sanitized_test_name := replace(step3, `\`, ``)
}

###############################################################################
# fmt_number_to_string(n) = ...
#
# Converts a number to string. If it's a float, ensure a decimal point.
# If it's an integer, keep it integer-like. Otherwise, return `n`.
###############################################################################

# Default rule if no conditions match (e.g., n is not numeric)
default fmt_number_to_string(n) = n

# Case #1: Float with 2 decimal places
fmt_number_to_string(n) = f {
    # Attempt the "%.2f" formatting
    maybe_float := sprintf("%.2f", [n])
    contains(maybe_float, ".")   # This ensures it's recognized as float
    f := maybe_float
}

# Case #2: Integer-like
fmt_number_to_string(n) = f {
    # Check that "%.2f" does NOT contain a dot
    not contains(sprintf("%.2f", [n]), ".")
    f := sprintf("%v", [n])
}

