###########################################################
# automated_test_validation.rego
#
# This policy checks automated test validation for
# traceability data and compares them with 7PS test
# execution results.
#
# Key Performance & Syntax Fixes:
# 1) Use sets/dictionaries for faster lookups.
# 2) Rename or remove conflicting variables to avoid
#    "var x declared above" errors.
# 3) Combine repeated logic into single pass constructs.
#
###########################################################

package policy.enforcement.TMM.automated_test_validation

import data.policy.lib.data
import data.policy.lib.functions.match_test_names
import data.policy.lib.functions.is_empty_or_undefined
import data.policy.lib.functions.in_array
import data.policy.lib.functions.valid_status
import rego.v1

###########################################################
# Step 1: Build dictionary => testCaseId -> set of statuses
###########################################################
sevenps_entry := {
  t.testCaseId: {
    st |
    test_row := input.sevenps_test_cases[_]
    test_row.testCaseId == t.testCaseId
    st := test_row.status
  } |
  t := input.sevenps_test_cases[_]
}

###########################################################
# Step 2: Build a set of all JIRA IDs from traceability_data
###########################################################
traceability_jira_ids := {
  tr.jira_id |
  tr := input.traceability_data[_]
}

###########################################################
# Step 3: Filter only valid traceability data items,
#         i.e., those whose jira_id is present in input.jira_data.
###########################################################
valid_traceability_data := {
  vt |
  vt := input.traceability_data[_]
  vt.jira_id in input.jira_data
}

###########################################################
# Step 4: Create a set of test cases from valid traceability data
###########################################################
unique_jira_test_cases := {
  testC |
  valid_entry := valid_traceability_data[_]
  testC := valid_entry.test_cases[_]
}

###########################################################
# Step 5: For each unique test case, gather statuses from
#         sevenps_entry. If no direct key, fallback to regex.
###########################################################

# Exact match
jira_test_case_statuses[test_case] := statuses if {
  test_case := unique_jira_test_cases[_]
  sevenps_entry[test_case]        # ensure direct match exists
  statuses := sevenps_entry[test_case]
}

# Regex fallback match
jira_test_case_statuses[test_case] := regex_statuses if {
  test_case := unique_jira_test_cases[_]
  not sevenps_entry[test_case]
  regex_statuses := {
    st |
    row := input.sevenps_test_cases[_].testCaseId
    match_test_names(test_case, row)
    st := sevenps_entry[row][_]
  }
}

###########################################################
# Step 6: Identify missing JIRA IDs that are in input.jira_data
#         but not in traceability_jira_ids
###########################################################
missing_jira_ids contains jira_id if {
  jira_id := input.jira_data[_]
  not in_array(traceability_jira_ids, jira_id)
}

###########################################################
# Step 7: Identify missing or invalid test cases
#         We define them as:
#          - 7PS results are empty/undefined
#            OR
#          - no valid status found
###########################################################
missing_test_case_id contains test_case if {
  test_case := unique_jira_test_cases[_]
  statuses := jira_test_case_statuses[test_case]
  is_empty_or_undefined(statuses)
  or
  not valid_status(statuses)
}

###########################################################
# Step 8: Produce final results object as partial outputs
###########################################################

results["missing_id_automated"] := missing_test_case_id if {
  count(missing_test_case_id) > 0
} else := ""

results["missing_jira_ids"] := missing_jira_ids if {
  count(missing_jira_ids) > 0
} else := []

results["decision"] := "PASS" if {
  count(missing_test_case_id) == 0
  count(missing_jira_ids) == 0
} else := "FAIL"

results["total_traceability_tests"] := test_count if {
  test_count := count(unique_jira_test_cases)
} else := 0

results["valid_traceability_tests"] := valid_count if {
  total_count := count(unique_jira_test_cases)
  missing_count := count(missing_test_case_id)
  valid_count := total_count - missing_count
} else := 0





##################################################3






###########################################################
# functions.rego
#
# Library of helper functions used by multiple policies:
#   - Checking emptiness (is_empty_or_undefined)
#   - Matching test names (match_test_names)
#   - Sanitizing test names (sanitize_test_names)
#   - Converting numbers to strings (fmt_number_to_string)
#   - Checking if element is in an array/set (in_array)
#   - Checking if a status list is valid (valid_status)
###########################################################

package policy.lib.functions

import rego.v1
import data.policy.lib.data

###########################################################
# 1. is_empty_or_undefined(response)
###########################################################
is_empty_or_undefined(response) if {
    not response
} else if {
    response == ""
} else if {
    response == {}
} else if {
    response == []
}

###########################################################
# 2. match_test_names(test_case_name, test_result_name)
###########################################################
match_test_names(test_case_name, test_result_name) if {
    sanitized_test_case_name := sanitize_test_names(test_case_name)
    sanitized_test_result_name := sanitize_test_names(test_result_name)
    match_sanitized_test_names(sanitized_test_case_name, sanitized_test_result_name)
} else := false

###########################################################
# 3. match_sanitized_test_names(nameA, nameB)
#
# Attempts exact match, then tries known regex patterns,
# finally placeholders like <...> or {...}.
###########################################################
match_sanitized_test_names(sanitized_test_case_name, sanitized_test_result_name) if {
    # 1) Direct match
    sanitized_test_case_name == sanitized_test_result_name
} else if {
    # 2) Example pattern: "7-@[0-9]+7.[0-9]+7.*"
    end_pattern := `7-@[0-9]+7.[0-9]+7.*`
    pattern := sprintf("%s%s", [sanitized_test_case_name, end_pattern])
    regex.template_match(pattern, sanitized_test_result_name, "S", "F")
} else if {
    # 3) Example pattern: "#[0-9]+?"
    end_pattern := `#[0-9]+?`
    pattern := sprintf("%s%sF", [sanitized_test_case_name, end_pattern])
    regex.template_match(pattern, sanitized_test_result_name, "S", "F")
} else if {
    # 4) Example pattern: "\(example#[0-9]\)"
    end_pattern := `\(example#[0-9]\)`
    pattern := sprintf("%s%s", [sanitized_test_case_name, end_pattern])
    regex.template_match(pattern, sanitized_test_result_name, "S", "F")
} else if {
    # 5) Start pattern example: "[[0-9]+7(7:[0-9]+7)7:[0-9]+]"
    start_pattern := `[[0-9]+7(7:[0-9]+7)7:[0-9]+]`
    pattern := sprintf("%s%s", [start_pattern, sanitized_test_result_name])
    regex.template_match(pattern, sanitized_test_case_name, "S", "F")
} else if {
    # 6) Handle placeholders like <...>
    contains(sanitized_test_case_name, "<")
    contains(sanitized_test_case_name, ">")
    substrings_of_test_case := regex.split(`<(.*?)>`, sanitized_test_case_name)
    count({
        ss |
        substrings_of_test_case[ss]
        contains(sanitized_test_result_name, substrings_of_test_case[ss])
    }) == count(substrings_of_test_case)
} else if {
    # 7) Handle placeholders like {...}
    contains(sanitized_test_case_name, "{")
    contains(sanitized_test_case_name, "}")
    substrings_of_test_case := regex.split(`<(.*?)>`, sanitized_test_case_name)
    count({
        ss |
        substrings_of_test_case[ss]
        contains(sanitized_test_result_name, substrings_of_test_case[ss])
    }) == count(substrings_of_test_case)
} else := false

###########################################################
# 4. sanitize_test_names(test_name) => string
###########################################################
sanitize_test_names(test_name) := sanitized_test_name if {
    lowered_no_spaces_name := lower(replace(test_name, " ", ""))
    # Convert known unicode representations of < and >
    unicode_literal_test_name := replace(
        replace(
            replace(lowered_no_spaces_name, "\\u203a", ">"),
            "\\u003e",
            ">"
        ),
        "\\u003c",
        "<"
    )
    # Remove backslashes
    sanitized_test_name := replace(unicode_literal_test_name, `\`, ``)
} else := test_name

###########################################################
# 5. fmt_number_to_string(n)
###########################################################
fmt_number_to_string(n) := f if {
    # Convert float to string and validate it is a float 
    f := sprintf("%.2f", [n])
    contains(f, ".")
} else := f if {
    # Convert int to string
    not contains(sprintf("%.2f", [n]), ".")
    f := sprintf("%w", [n])
} else := n

###########################################################
# 6. in_array(arr, elem)
#
# Checks membership in either a set or array.
###########################################################
in_array(arr, elem) if {
    # If arr is a set
    not is_array(arr)
    elem in arr
} else if {
    # If arr is an array
    is_array(arr)
    arr[_] == elem
}

###########################################################
# 7. valid_status(status_list)
#
# Returns true if at least one status in `status_list`
# is found in data.valid_automated_test_case_status.
###########################################################
valid_status(status_list) if {
    some st
    status_list[st]
    st in data.valid_automated_test_case_status
}
