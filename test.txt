

###############################

---------------------------------------------------
--- Performance Concerns & Possible Improvements
---------------------------------------------------
Common Rego performance pitfalls include:

1) Repeated Full Scans: Doing repeated array comprehensions with some i / some j can be expensive if input.sevenps_test_cases or traceability_data is large.

2) Membership Checks: Using in_array() with [arr[_] = elem] repeatedly can be costly if arrays are large. Switching to sets or dictionaries typically yields better membership check performance.

3) Double Computations: Building intermediate arrays, then scanning them again. We can often unify steps into a single comprehension.

4) Regex: Regex can be expensive. If possible, reduce the number of test-case pairs that must be checked with match_test_names.

5) Overly Complex or Duplicate Rules: If you rely heavily on some i, some j in nested loops, rewriting them as set/dict comprehensions can be more efficient.

--- Key Strategies
1) Use Sets Instead of Arrays: In Rego, a set membership check (x in myset) is more efficient than scanning large arrays.

2) Consolidate Comprehensions: Instead of building arrays of arrays, we can sometimes do a single set comprehension to produce exactly what we need.

3) Partial Evaluation (advanced): If your input structure is somewhat stable and you can partially evaluate the policy with known static data, it can drastically reduce runtime overhead in certain use cases.

4) Avoid Re-Regexing: If you have many testCaseIds and only a few that lack an exact match, you might short-circuit or more directly group testCaseIds that need regex.



---------------------------------------------------
--- How It Improves Performance
---------------------------------------------------

Below is a refactored version of the policy that uses set/dict comprehensions more extensively, reducing nested loops and repeated membership checks. We also clean up a few suspicious lines (like count(test_case) > 0). Comments included to explain changes.



---------------------------------------------------
--- What Changed & Why It’s Faster
---------------------------------------------------

1) Use of Set Comprehensions
- sevenps_entry and unique_jira_test_cases are now built via single-pass comprehensions.
- For membership, we can directly use elem in myset rather than looping. This is often faster for large data sets.

2) Eliminated Nested Loops
- Instead of “for each i, do a nested j search,” we do a single set-comprehension that collects all statuses for each testCaseId at once.

3) Reduced Repetitive "some i"
- The original code used multiple some i/some j blocks. In large collections, that can cause repeated scans.


4) Regex Only for Unmatched Cases

- We do an exact match check first (sevenps_entry[test_case]). Only if that does not exist do we attempt a more expensive regex loop. This short-circuits many test cases that do have direct matches.

5) Cleaner Missing Test Case Logic

We unify the logic for “missing test case” into one set, removing the suspicious usage of count(test_id) > 8. This not only clarifies the intention but can reduce confusion/maintenance cost.


---------------------------------------------------
--- Final Recap
---------------------------------------------------

1) Original Policy Explanation

The policy collects statuses from sevenps_test_cases, cross-references them with Jira ID data from traceability_data and input.jira_data, then determines which test cases or Jira IDs are missing or invalid. It finally produces a pass/fail decision and some summary counts.

2) Performance Bottlenecks

Multiple nested loops, array membership checks, and repeated comprehensions can make the policy run slowly on large inputs.

3) Refactored Policy

Uses sets for membership, single-pass comprehensions to reduce repeated scans, avoids unnecessary looping, and short-circuits expensive regex checks.

This reduces the overhead significantly and should improve runtime performance, especially if sevenps_test_cases or traceability_data have many items.



---------------------------------------------------
-- Code 
---------------------------------------------------

package policy.enforcement.TMM.automated_test_validation

# We assume these imports exist in your environment:
# - data.policy.lib.data (e.g. data.valid_automated_test_case_status, etc.)
# - data.policy.lib.functions.match_test_names (a helper function to do regex matching)
import data.policy.lib.data
import data.policy.lib.functions.match_test_names

#
# SECTION 1: Build a dictionary of testCaseId -> set of statuses
#
# Explanation:
#   - We want to combine all statuses of the same testCaseId from input.sevenps_test_cases.
#   - "sevenps_entry[tcase]" will be a set of statuses, e.g. {"passed","blocked"}.
#
# Example:
#   If input.sevenps_test_cases = [
#     {"testCaseId": "TC-1", "status": "passed"},
#     {"testCaseId": "TC-1", "status": "blocked"},
#     {"testCaseId": "TC-2", "status": "failed"}
#   ],
#   Then:
#     sevenps_entry["TC-1"] = {"passed","blocked"}
#     sevenps_entry["TC-2"] = {"failed"}
#
sevenps_entry := {
    tcase: { tc.status |
        tc := input.sevenps_test_cases[_]
        tc.testCaseId == tcase
    } 
    |
    # This part is collecting unique testCaseIds from the entire input
    tcase := { x.testCaseId | x := input.sevenps_test_cases[_] }[_]
}

#
# SECTION 2: Create a set of all jira_ids mentioned in the traceability data
#
# Explanation:
#   - We read input.traceability_data[] entries, and each entry has a "jira_id".
#   - We just collect them in a set for fast membership checks later.
#
# Example:
#   If input.traceability_data = [
#     {"jira_id": "JIRA-100", "test_cases": ["TC-1", "TC-2"]},
#     {"jira_id": "JIRA-200", "test_cases": ["TC-3"]}
#   ],
#   Then traceability_jira_ids = {"JIRA-100", "JIRA-200"}.
#
traceability_jira_ids := {
    item.jira_id |
    item := input.traceability_data[_]
}

#
# SECTION 3: Keep only "valid" traceability data
#
# Explanation:
#   - "Valid" is defined as an item whose jira_id is also present in input.jira_data.
#   - Suppose input.jira_data = ["JIRA-100","JIRA-200"]. Then any item in
#     input.traceability_data that has a jira_id not in that list will be excluded.
#
# Example:
#   If input.traceability_data = [
#     {"jira_id": "JIRA-100", "test_cases": ["TC-1"]},
#     {"jira_id": "JIRA-999", "test_cases": ["TC-99"]}
#   ]
#   and input.jira_data = ["JIRA-100","JIRA-200"],
#   then valid_traceability_data =
#     {
#       {"jira_id": "JIRA-100", "test_cases": ["TC-1"]}
#     }
#   because "JIRA-999" is not in the official list.
#
valid_traceability_data := {
    item |
    item := input.traceability_data[_]
    item.jira_id in input.jira_data
}

#
# SECTION 4: Collect all testCaseIds from the valid traceability items
#
# Explanation:
#   - Each item in valid_traceability_data has "test_cases": [..].
#   - We want a set of every unique testCaseId from those arrays.
#
# Example:
#   If valid_traceability_data = {
#     {"jira_id": "JIRA-100", "test_cases": ["TC-1","TC-2"]},
#     {"jira_id": "JIRA-200", "test_cases": ["TC-3"]}
#   },
#   Then unique_jira_test_cases = {"TC-1","TC-2","TC-3"}.
#
unique_jira_test_cases := {
    tcase |
    entry := valid_traceability_data[_]
    tcase := entry.test_cases[_]
}

#
# SECTION 5: Build "jira_test_case_statuses" dictionary
#            for each test case in unique_jira_test_cases.
#
# Explanation:
#   - We want to find the set of statuses that belongs to each test case from the "sevenps_entry".
#   - First, we try an "exact match": if sevenps_entry[test_case] exists, use that set directly.
#   - If there's no exact match, we do a "regex-based" match on the keys in sevenps_entry.
#   - The final dictionary key is "test_case", and the value is the set of statuses.
#
# Examples:
#   1) Suppose "TC-1" is actually in sevenps_entry as a direct key. Then we do:
#        jira_test_case_statuses["TC-1"] = sevenps_entry["TC-1"] (e.g., {"passed","blocked"}).
#   2) If "TC-XYZ" is not in sevenps_entry, but we discover via regex that it matches
#      some existing "TC-XYZ_v2" key, then we gather all statuses from that matched key.
#

# (5a) Exact match:
jira_test_case_statuses[test_case] := sts if {
    test_case := unique_jira_test_cases[_]
    sts := sevenps_entry[test_case]  # This works only if test_case is exactly in sevenps_entry
}

# (5b) Regex-based match:
jira_test_case_statuses[test_case] := combined if {
    test_case := unique_jira_test_cases[_]

    # "not sevenps_entry[test_case]" means there's no exact match for "test_case".
    not sevenps_entry[test_case]

    # Next, we gather all statuses from any "key" in sevenps_entry that
    # matches "test_case" via the "match_test_names" function.
    combined := {
        s |
        key := keys(sevenps_entry)[_]  # get each possible testCaseId key in sevenps_entry
        match_test_names(test_case, key)
        s := sevenps_entry[key][_]     # for each status in that matching key's set
    }
}

#
# SECTION 6: Utility function (optional).
#   "in_set" is a quick membership check for sets, though in modern OPA
#   you can simply write "elem in myset" instead.
#
in_set(myset, elem) {
    elem in myset
}

#
# SECTION 7: Validate if a set of statuses contains at least one "valid" status.
#
# Explanation:
#   - data.valid_automated_test_case_status might be something like {"passed", "blocked", "failed"}.
#   - "valid_status(status_set)" is true if status_set intersects with
#     data.valid_automated_test_case_status at least once.
#
# Example:
#   If status_set = {"passed","blocked"}, it's valid because it has
#   "passed" in the valid_automated_test_case_status set.
#   If status_set = {"invalid","untested"}, it is not valid.
#
valid_status(status_set) {
    some st
    st in status_set
    st in data.valid_automated_test_case_status
}

#
# SECTION 8: missing_jira_ids
#
# Explanation:
#   - We check each jira_id in input.jira_data to see if it's absent in traceability_jira_ids.
#   - If "jira_id" is not in traceability_jira_ids, it is considered "missing".
#
# Example:
#   If input.jira_data = ["JIRA-100","JIRA-200","JIRA-300"]
#   and traceability_jira_ids = {"JIRA-100","JIRA-200"},
#   then missing_jira_ids = {"JIRA-300"}.
#
missing_jira_ids := {
    jira_id |
    jira_id := input.jira_data[_]
    not (jira_id in traceability_jira_ids)
}

#
# SECTION 9: missing_test_case_id
#
# Explanation:
#   This is a set of all test cases that are considered "missing". We unify two scenarios:
#   1) A test case in unique_jira_test_cases isn't found at all in jira_test_case_statuses.
#   2) The test case is found, but doesn't contain any valid statuses (passed, blocked, etc.).
#
# Example:
#   - If a test case "TC-404" appears in unique_jira_test_cases but not in sevenps_entry or
#     doesn't match anything by regex, it won't appear in jira_test_case_statuses => missing.
#   - If a test case has statuses = {"invalid_status"}, then "valid_status" is false => missing.
#
missing_test_case_id := {
    tcase |
    # Scenario 1: No entry in jira_test_case_statuses at all
    tcase := unique_jira_test_cases[_]
    not jira_test_case_statuses[tcase]
} union {
    tcase |
    # Scenario 2: Has an entry, but that set doesn't contain a valid status
    tcase := unique_jira_test_cases[_]
    jira_test_case_statuses[tcase]
    not valid_status(jira_test_case_statuses[tcase])
}

#
# SECTION 10: Final results object
#
# Explanation:
#   - We produce a single "results" object with multiple keys:
#     1) "missing_id_automated": the set of missing test case IDs (or empty if none missing)
#     2) "missing_jira_ids": any JIRA IDs that were expected but not found
#     3) "decision": "PASS" if no missing test cases / JIRA IDs, otherwise "FAIL"
#     4) "total_traceability_tests": total # of test cases from the traceability perspective
#     5) "valid_traceability_tests": total # minus however many are missing
#

results := {
    "missing_id_automated": missing_id_automated,
    "missing_jira_ids": missing_jiras,
    "decision": decision,
    "total_traceability_tests": total_tests,
    "valid_traceability_tests": valid_tests
}

# 10a) If there are missing test cases, store them in "missing_id_automated". Otherwise store "".
missing_id_automated := missing_test_case_id if count(missing_test_case_id) > 0
missing_id_automated := "" if count(missing_test_case_id) == 0

# 10b) If there are missing JIRA IDs, store them in "missing_jira_ids". Otherwise store [].
missing_jiras := missing_jira_ids if count(missing_jira_ids) > 0
missing_jiras := [] if count(missing_jira_ids) == 0

# 10c) Decision: if NOTHING is missing, we pass. Otherwise, we fail.
decision := "PASS" if {
    count(missing_test_case_id) == 0
    count(missing_jira_ids) == 0
}
decision := "FAIL" if not (count(missing_test_case_id) == 0 and count(missing_jira_ids) == 0)

# 10d) total_traceability_tests: number of unique test cases gleaned from the valid traceability data.
total_tests := count(unique_jira_test_cases) if count(unique_jira_test_cases) > 0
total_tests := 0 if count(unique_jira_test_cases) == 0

# 10e) valid_traceability_tests: total tests minus those that are missing. If none or no total, 0.
valid_tests := total_tests - count(missing_test_case_id) if total_tests > 0
valid_tests := 0 if total_tests == 0
