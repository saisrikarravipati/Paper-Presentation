



###########################################################
# automated_test_validation.rego
#
# Refactored to:
# 1) Avoid 'or' entirely.
# 2) Preserve performance by using:
#    - Dictionary for testCaseId -> statuses (sevenps_entry)
#    - Single partial set for missing test cases
# 3) Use a partial boolean function 'is_missing_or_invalid'
#    to handle "empty or invalid" logic without 'or'.
###########################################################

package policy.enforcement.TMM.automated_test_validation

import data.policy.lib.data
import data.policy.lib.functions.match_test_names
import data.policy.lib.functions.is_empty_or_undefined
import data.policy.lib.functions.in_array
import data.policy.lib.functions.valid_status
import rego.v1

###########################################################
# 1) Dictionary: testCaseId -> set of statuses
###########################################################
sevenps_entry := {
  t.testCaseId: {
    st |
    test_row := input.sevenps_test_cases[_]
    test_row.testCaseId == t.testCaseId
    st := test_row.status
  } |
  t := input.sevenps_test_cases[_]
}

###########################################################
# 2) Set of JIRA IDs from traceability_data
###########################################################
traceability_jira_ids := {
  tr.jira_id |
  tr := input.traceability_data[_]
}

###########################################################
# 3) Valid traceability data: items whose jira_id is in input.jira_data
###########################################################
valid_traceability_data := {
  vt |
  vt := input.traceability_data[_]
  vt.jira_id in input.jira_data
}

###########################################################
# 4) All test cases found in valid_traceability_data
###########################################################
unique_jira_test_cases := {
  testC |
  valid_entry := valid_traceability_data[_]
  testC := valid_entry.test_cases[_]
}

###########################################################
# 5) For each test case, gather statuses from sevenps_entry.
#    If not found directly, fallback to regex-based match.
###########################################################

# 5a) Exact match
jira_test_case_statuses[test_case] := statuses if {
  test_case := unique_jira_test_cases[_]
  sevenps_entry[test_case]
  statuses := sevenps_entry[test_case]
}

# 5b) Regex fallback match
jira_test_case_statuses[test_case] := regex_statuses if {
  test_case := unique_jira_test_cases[_]
  not sevenps_entry[test_case]
  regex_statuses := {
    st |
    row := input.sevenps_test_cases[_].testCaseId
    match_test_names(test_case, row)
    st := sevenps_entry[row][_]
  }
}

###########################################################
# 6) Missing JIRA IDs: in input.jira_data, but not in traceability_jira_ids
###########################################################
missing_jira_ids contains jira_id if {
  jira_id := input.jira_data[_]
  not in_array(traceability_jira_ids, jira_id)
}

###########################################################
# 7) Identify "missing" test cases in a single partial set
#    by checking the partial function:
#       is_missing_or_invalid(statuses)
###########################################################
missing_test_case_id contains test_case if {
  test_case := unique_jira_test_cases[_]
  statuses := jira_test_case_statuses[test_case]
  is_missing_or_invalid(statuses)
}

###########################################################
# 8) Final results object
###########################################################

results["missing_id_automated"] := missing_test_case_id if {
  count(missing_test_case_id) > 0
} else := ""

results["missing_jira_ids"] := missing_jira_ids if {
  count(missing_jira_ids) > 0
} else := []

results["decision"] := "PASS" if {
  count(missing_test_case_id) == 0
  count(missing_jira_ids) == 0
} else := "FAIL"

results["total_traceability_tests"] := test_count if {
  test_count := count(unique_jira_test_cases)
} else := 0

results["valid_traceability_tests"] := valid_count if {
  total_count := count(unique_jira_test_cases)
  missing_count := count(missing_test_case_id)
  valid_count := total_count - missing_count
} else := 0


###########################################################
# Partial function: is_missing_or_invalid(statuses)
#
# This function returns TRUE if:
#   1) statuses is empty/undefined
#      -OR-
#   2) statuses exist but none are valid
#
# We define this as two partial rules so that if EITHER
# condition is satisfied, is_missing_or_invalid(...) is
# considered TRUE.
#
# We do not use 'or' in the code.
###########################################################

is_missing_or_invalid(statuses) if {
  is_empty_or_undefined(statuses)
}

is_missing_or_invalid(statuses) if {
  not is_empty_or_undefined(statuses)
  not valid_status(statuses)
}













#########################################################################









###########################################################
# functions.rego
#
# No changes needed here. We still avoid 'or' usage.
###########################################################

package policy.lib.functions

import rego.v1
import data.policy.lib.data

###########################################################
# 1. is_empty_or_undefined(response)
###########################################################
is_empty_or_undefined(response) if {
    not response
} else if {
    response == ""
} else if {
    response == {}
} else if {
    response == []
}

###########################################################
# 2. match_test_names(test_case_name, test_result_name)
###########################################################
match_test_names(test_case_name, test_result_name) if {
    sanitized_test_case_name := sanitize_test_names(test_case_name)
    sanitized_test_result_name := sanitize_test_names(test_result_name)
    match_sanitized_test_names(sanitized_test_case_name, sanitized_test_result_name)
} else := false

###########################################################
# 3. match_sanitized_test_names(nameA, nameB)
###########################################################
match_sanitized_test_names(sanitized_test_case_name, sanitized_test_result_name) if {
    # Direct match
    sanitized_test_case_name == sanitized_test_result_name
} else if {
    # Example pattern: "7-@[0-9]+7.[0-9]+7.*"
    end_pattern := `7-@[0-9]+7.[0-9]+7.*`
    pattern := sprintf("%s%s", [sanitized_test_case_name, end_pattern])
    regex.template_match(pattern, sanitized_test_result_name, "S", "F")
} else if {
    # Example pattern: "#[0-9]+?"
    end_pattern := `#[0-9]+?`
    pattern := sprintf("%s%sF", [sanitized_test_case_name, end_pattern])
    regex.template_match(pattern, sanitized_test_result_name, "S", "F")
} else if {
    # Example pattern: "\(example#[0-9]\)"
    end_pattern := `\(example#[0-9]\)`
    pattern := sprintf("%s%s", [sanitized_test_case_name, end_pattern])
    regex.template_match(pattern, sanitized_test_result_name, "S", "F")
} else if {
    # Start pattern example: "[[0-9]+7(7:[0-9]+7)7:[0-9]+]"
    start_pattern := `[[0-9]+7(7:[0-9]+7)7:[0-9]+]`
    pattern := sprintf("%s%s", [start_pattern, sanitized_test_result_name])
    regex.template_match(pattern, sanitized_test_case_name, "S", "F")
} else if {
    # Handle placeholders like <...>
    contains(sanitized_test_case_name, "<")
    contains(sanitized_test_case_name, ">")
    substrings_of_test_case := regex.split(`<(.*?)>`, sanitized_test_case_name)
    count({
        ss |
        substrings_of_test_case[ss]
        contains(sanitized_test_result_name, substrings_of_test_case[ss])
    }) == count(substrings_of_test_case)
} else if {
    # Handle placeholders like {...}
    contains(sanitized_test_case_name, "{")
    contains(sanitized_test_case_name, "}")
    substrings_of_test_case := regex.split(`<(.*?)>`, sanitized_test_case_name)
    count({
        ss |
        substrings_of_test_case[ss]
        contains(sanitized_test_result_name, substrings_of_test_case[ss])
    }) == count(substrings_of_test_case)
} else := false

###########################################################
# 4. sanitize_test_names(test_name) => string
###########################################################
sanitize_test_names(test_name) := sanitized_test_name if {
    lowered_no_spaces_name := lower(replace(test_name, " ", ""))
    # Convert known unicode representations of < and >
    unicode_literal_test_name := replace(
        replace(
            replace(lowered_no_spaces_name, "\\u203a", ">"),
            "\\u003e",
            ">"
        ),
        "\\u003c",
        "<"
    )
    sanitized_test_name := replace(unicode_literal_test_name, `\`, ``)
} else := test_name

###########################################################
# 5. fmt_number_to_string(n)
###########################################################
fmt_number_to_string(n) := f if {
    # Convert float to string
    f := sprintf("%.2f", [n])
    contains(f, ".")
} else := f if {
    # Convert int to string
    not contains(sprintf("%.2f", [n]), ".")
    f := sprintf("%w", [n])
} else := n

###########################################################
# 6. in_array(arr, elem)
###########################################################
in_array(arr, elem) if {
    not is_array(arr)
    elem in arr
} else if {
    is_array(arr)
    arr[_] == elem
}

###########################################################
# 7. valid_status(status_list)
###########################################################
valid_status(status_list) if {
    some st
    status_list[st]
    st in data.valid_automated_test_case_status
}







